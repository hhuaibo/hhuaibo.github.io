<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Charles</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.icharles.top/"/>
  <updated>2018-01-19T13:34:00.187Z</updated>
  <id>http://www.icharles.top/</id>
  
  <author>
    <name>Charles</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KMP</title>
    <link href="http://www.icharles.top/2018/01/19/KMP/"/>
    <id>http://www.icharles.top/2018/01/19/KMP/</id>
    <published>2018-01-19T13:31:00.000Z</published>
    <updated>2018-01-19T13:34:00.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用Next数组来求连续字符串的个数"><a href="#利用Next数组来求连续字符串的个数" class="headerlink" title="利用Next数组来求连续字符串的个数"></a>利用Next数组来求连续字符串的个数</h1><h3 id="题目地址：Power-Strings"><a href="#题目地址：Power-Strings" class="headerlink" title="题目地址：Power Strings "></a>题目地址：<a href="https://vjudge.net/problem/POJ-2406" target="_blank" rel="noopener">Power Strings </a></h3><blockquote><p>题目大体意思就是求连续字符串个数<br>由于刚学习完KMP，就想到了利用Next数组来求连续字符串的个数，发现存在以下关系： N = len / (len - next[len])       </p></blockquote><pre><code class="c">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1E6 + 5;char str[maxn];int nex[maxn], len;void getnext(){    int i = 0, j = -1;    memset(nex, 0, sizeof(nex));    nex[0] = -1;    while(i &lt; len) {        if(j == -1 || str[i] == str[j]) {            nex[++i] = ++j;        }        else {            j = nex[j];        }    }}int main(){    while(scanf(&quot;%s&quot;, str) != EOF) {        if(str[0] ==&#39;.&#39;) break;        len = strlen(str);        getnext();    //例如 aaaaa len = 4, len - nex[len] = 1        if(len % (len - nex[len]) == 0) cout &lt;&lt; len / (len - nex[len]) &lt;&lt; endl;        else cout &lt;&lt; &quot;1&quot; &lt;&lt; endl;    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用Next数组来求连续字符串的个数&quot;&gt;&lt;a href=&quot;#利用Next数组来求连续字符串的个数&quot; class=&quot;headerlink&quot; title=&quot;利用Next数组来求连续字符串的个数&quot;&gt;&lt;/a&gt;利用Next数组来求连续字符串的个数&lt;/h1&gt;&lt;h3 id=&quot;题
      
    
    </summary>
    
      <category term="算法" scheme="http://www.icharles.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>谷歌访问助手</title>
    <link href="http://www.icharles.top/2018/01/04/%E8%B0%B7%E6%AD%8C%E8%AE%BF%E9%97%AE%E5%8A%A9%E6%89%8B/"/>
    <id>http://www.icharles.top/2018/01/04/谷歌访问助手/</id>
    <published>2018-01-04T04:21:32.000Z</published>
    <updated>2018-01-16T10:12:38.192Z</updated>
    
    <content type="html"><![CDATA[<h3 id="谷歌访问助手安装教程"><a href="#谷歌访问助手安装教程" class="headerlink" title="谷歌访问助手安装教程"></a>谷歌访问助手安装教程</h3><blockquote><ul><li>本教程以Google Chrome为例，其他浏览器请自行安装，激活方法一样</li></ul></blockquote><ol><li><p>打开Google Chrome浏览器，如下图<br><img src="http://icharles.top/2018/01/04/谷歌访问助手/1.png" alt="1"></p></li><li><p>将下载的谷歌访问助手拖到扩展程序<br><img src="http://icharles.top/2018/01/04/谷歌访问助手/2.png" alt="2"></p></li><li><p>永久激活谷歌访问助手，按照提示进行即可<br><img src="http://icharles.top/2018/01/04/谷歌访问助手/3.png" alt="3"><br><img src="http://icharles.top/2018/01/04/谷歌访问助手/4.png" alt="4"></p></li><li><p>当然你不会或者嫌麻烦设置主页，可以按照下图步骤<br>点击设置<br><img src="http://icharles.top/2018/01/04/谷歌访问助手/5.png" alt="5"><br>勾选自动打开主页<br><img src="http://icharles.top/2018/01/04/谷歌访问助手/6.png" alt="6">  </p></li></ol><h4 id="至此，你就完成所有设置，接下来就是畅游墙外世界"><a href="#至此，你就完成所有设置，接下来就是畅游墙外世界" class="headerlink" title="至此，你就完成所有设置，接下来就是畅游墙外世界"></a>至此，你就完成所有设置，接下来就是畅游墙外世界</h4><h4 id="别忘记点赞呦"><a href="#别忘记点赞呦" class="headerlink" title="别忘记点赞呦"></a>别忘记点赞呦</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;谷歌访问助手安装教程&quot;&gt;&lt;a href=&quot;#谷歌访问助手安装教程&quot; class=&quot;headerlink&quot; title=&quot;谷歌访问助手安装教程&quot;&gt;&lt;/a&gt;谷歌访问助手安装教程&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;本教程以Google Chrome为例
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu</title>
    <link href="http://www.icharles.top/2017/12/30/Ubuntu/"/>
    <id>http://www.icharles.top/2017/12/30/Ubuntu/</id>
    <published>2017-12-30T06:12:00.000Z</published>
    <updated>2018-01-16T10:11:17.682Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Ubuntu安装教程"><a href="#Ubuntu安装教程" class="headerlink" title="Ubuntu安装教程"></a>Ubuntu安装教程</h3><h3 id="Ubuntu-16-04安装步骤："><a href="#Ubuntu-16-04安装步骤：" class="headerlink" title="Ubuntu 16.04安装步骤："></a>Ubuntu 16.04安装步骤：</h3><p>一、U盘安装准备步骤</p><p>(1) <a href="http://cn.ubuntu.com/download/" target="_blank" rel="noopener">官网下载</a> <strong>Ubuntu16.04</strong> 系统ISO镜像<br><img src="http://www.linuxidc.com/upload/2017_07/17072609596256.jpg" alt="Ubuntu"></p><p>(2) 准备U盘一个，4G左右就够了，用于制作安装u盘</p><p>制作安装U盘，推荐使用软件：<a href="https://www.pendrivelinux.com/universal-usb-installer-easy-as-1-2-3/" target="_blank" rel="noopener">universal-usb-installer</a><br><img src="https://www.pendrivelinux.com/wp-content/uploads/Universal-USB-Installer.png" alt="universal-usb-installer">  </p><p>将U盘插入电脑  </p><blockquote><p>第一步: 下拉列表选择Ubuntu（当然安装其他发行版时也可以选择相应的title）。<br>第二步: 单击右侧的Browse按钮，选择下载好的.iso格式的系统镜像。<br>第三步: 选择插入的U盘，一般默认的就是。根据要求是否进行格式化，其余按照默认的参数，单击create，等待一会儿后就可以了。<br>结束画面如下：  </p></blockquote><p><img src="https://www.pendrivelinux.com/wp-content/uploads/Universal-USB-Installer2.png" alt="">  </p><p>二、Ubuntu系统空间准备</p><p>在Windows 10中打开“磁盘管理器”，找一个空闲的磁盘分区，压缩出来一部分空间给Ubuntu使用，压缩出来的硬盘应处于未分配状态。或者通过删除某个不使用的本地磁盘使其处于未分配状态。<br><img src="https://upload-images.jianshu.io/upload_images/1272002-334e3e33d83fd8b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="">    </p><blockquote><p>绿色框中是留给Ubuntu的空间</p></blockquote><p>三、BIOS设置<br>1.关机，重新打开电脑，进入BIOS，关闭Windows系统的快速启动（Fast Boot）选项，即设置为Disable状态。<br><img src="https://upload-images.jianshu.io/upload_images/1272002-42f06103698c8961.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""><br>2.在BIOS中设置U盘为第一启动项，关闭电脑。</p><p>四、安装Ubuntu 16.04<br>1.从U盘启动，进入刻录到U盘的Ubuntu系统中</p><p>2.选择试用Install Ubuntu    </p><p><img src="https://upload-images.jianshu.io/upload_images/1272002-ee7ebc172f38ab02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="">    </p><p><img src="https://upload-images.jianshu.io/upload_images/1272002-3d0beb819c154274.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="">    </p><p><img src="https://upload-images.jianshu.io/upload_images/1272002-6eb497d6e84d50d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p><blockquote><p>在硬盘中Ubuntu检测到有Windows系统存在，所以会默认使用未分配的那部分空间安 装Ubuntu。这也是刚开始说的方便之处，避免了自己分区的不合理<br>当然你也可以选择<strong>其他选项</strong>自定义安装，分区方案如下：</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1272002-f7a72a5a941e4537.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/614" alt=""></p><p>3.配置完成后，接下来下载更新，自动安装</p><p><img src="https://upload-images.jianshu.io/upload_images/1272002-b00039c66f342e51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p><p>完成安装后，美化你的Ubuntu吧：<a href="http://www.linuxidc.com/Linux/2016-09/135165.htm" target="_blank" rel="noopener">美化教程</a></p><p>本文来自于：<a href="http://www.jianshu.com/p/16b36b912b02" target="_blank" rel="noopener">七双叶</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Ubuntu安装教程&quot;&gt;&lt;a href=&quot;#Ubuntu安装教程&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu安装教程&quot;&gt;&lt;/a&gt;Ubuntu安装教程&lt;/h3&gt;&lt;h3 id=&quot;Ubuntu-16-04安装步骤：&quot;&gt;&lt;a href=&quot;#Ubun
      
    
    </summary>
    
    
      <category term="Ubuntu" scheme="http://www.icharles.top/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>俄罗斯方块</title>
    <link href="http://www.icharles.top/2017/12/29/%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97/"/>
    <id>http://www.icharles.top/2017/12/29/俄罗斯方块/</id>
    <published>2017-12-29T14:16:00.000Z</published>
    <updated>2017-12-29T14:41:34.057Z</updated>
    
    <content type="html"><![CDATA[<p>本文代码下载地址: <a href="/download/俄罗斯方块.zip">俄罗斯方块.c</a><br>本文程序下载地址: <a href="/download/俄罗斯方块.exe">俄罗斯方块.exe</a></p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;conio.h&gt;#include &lt;windows.h&gt;#ifdef _MSC_VER  // M$的编译器要给予特殊照顾#if _MSC_VER &lt;= 1200  // VC6及以下版本#error 你是不是还在用VC6？！#else  // VC6以上版本#if _MSC_VER &gt;= 1600  // 据说VC10及以上版本有stdint.h了#include &lt;stdint.h&gt;#else  // VC10以下版本，自己定义int8_t和uint16_ttypedef signed char int8_t;typedef unsigned short uint16_t;#endif#ifndef __cplusplus  // 据说VC都没有stdbool.h，不用C++编译，自己定义booltypedef int bool;#define true 1#define false 0#endif#endif#else  // 其他的编译器都好说#include &lt;stdint.h&gt;#ifndef __cplusplus  // 不用C++编译，需要stdbool.h里的bool#include &lt;stdbool.h&gt;#endif#endif// =============================================================================// 7种方块的4旋转状态（4位为一行）static const uint16_t gs_uTetrisTable[7][4] = {         { 0x00F0U, 0x2222U, 0x00F0U, 0x2222U },  // I型        { 0x0072U, 0x0262U, 0x0270U, 0x0232U },  // T型        { 0x0223U, 0x0074U, 0x0622U, 0x0170U },  // L型        { 0x0226U, 0x0470U, 0x0322U, 0x0071U },  // J型        { 0x0063U, 0x0264U, 0x0063U, 0x0264U },  // Z型        { 0x006CU, 0x0462U, 0x006CU, 0x0462U },  // S型        { 0x0660U, 0x0660U, 0x0660U, 0x0660U }   // O型};// =============================================================================// 初始状态的游戏池// 每个元素表示游戏池的一行，下标大的是游戏池底部// 两端各置2个1，底部2全置为1，便于进行碰撞检测// 这样一来游戏池的宽度为12列// 如果想要传统的10列，只需多填两个1即可（0xE007），当然显示相关部分也要随之改动// 当某个元素为0xFFFFU时，说明该行已被填满// 顶部4行用于给方块，不显示出来// 再除去底部2行，显示出来的游戏池高度为22行static const uint16_t gs_uInitialTetrisPool[28] = { 0xC003U, 0xC003U, 0xC003U,        0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U,        0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U,        0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xFFFFU,        0xFFFFU };#define COL_BEGIN 2#define COL_END 14#define ROW_BEGIN 4#define ROW_END 26// =============================================================================typedef struct TetrisManager  // 这个结构体存储游戏相关数据{    uint16_t pool[28];  // 游戏池    int8_t x;  // 当前方块x坐标，此处坐标为方块左上角坐标    int8_t y;  // 当前方块y坐标    int8_t type[3];  // 当前、下一个和下下一个方块类型    int8_t orientation[3];  // 当前、下一个和下下一个方块旋转状态    unsigned score;  // 得分    unsigned erasedCount[4];  // 消行数    unsigned erasedTotal;  // 消行总数    unsigned tetrisCount[7];  // 各方块数    unsigned tetrisTotal;  // 方块总数    bool dead;  // 挂} TetrisManager;// =============================================================================typedef struct TetrisControl  // 这个结构体存储控制相关数据{    bool pause;  // 暂停    bool clockwise;  // 旋转方向：顺时针为true    int8_t direction;  // 移动方向：0向左移动 1向右移动    // 游戏池内每格的颜色    // 由于此版本是彩色的，仅用游戏池数据无法存储颜色信息    // 当然，如果只实现单色版的，就没必要用这个数组了    int8_t color[28][16];} TetrisControl;HANDLE g_hConsoleOutput;  // 控制台输出句柄// =============================================================================// 函数声明// 如果使用全局变量方式实现，就没必要传参了void initGame(TetrisManager *manager, TetrisControl *control);  // 初始化游戏void restartGame(TetrisManager *manager, TetrisControl *control);  // 重新开始游戏void giveTetris(TetrisManager *manager);  // 给一个方块bool checkCollision(const TetrisManager *manager);  // 碰撞检测void insertTetris(TetrisManager *manager);  // 插入方块void removeTetris(TetrisManager *manager);  // 移除方块void horzMoveTetris(TetrisManager *manager, TetrisControl *control);  // 水平移动方块void moveDownTetris(TetrisManager *manager, TetrisControl *control);  // 向下移动方块void rotateTetris(TetrisManager *manager, TetrisControl *control);  // 旋转方块void dropDownTetris(TetrisManager *manager, TetrisControl *control);  // 方块直接落地bool checkErasing(TetrisManager *manager, TetrisControl *control);  // 消行检测void keydownControl(TetrisManager *manager, TetrisControl *control, int key); // 键按下void setPoolColor(const TetrisManager *manager, TetrisControl *control); // 设置颜色void gotoxyWithFullwidth(short x, short y);  // 以全角定位void printPoolBorder();  // 显示游戏池边界void printTetrisPool(const TetrisManager *manager, const TetrisControl *control); // 显示游戏池void printCurrentTetris(const TetrisManager *manager,        const TetrisControl *control);  // 显示当前方块void printNextTetris(const TetrisManager *manager);  // 显示下一个和下下一个方块void printScore(const TetrisManager *manager);  // 显示得分信息void runGame(TetrisManager *manager, TetrisControl *control);  // 运行游戏void printPrompting();  // 显示提示信息bool ifPlayAgain();  // 再来一次// =============================================================================// 出处：http://www.oschina.net/code/snippet_255612_16922// 主函数int main() {    TetrisManager tetrisManager;    TetrisControl tetrisControl;    initGame(&amp;tetrisManager, &amp;tetrisControl);  // 初始化游戏    do {        printPrompting();  // 显示提示信息        printPoolBorder();  // 显示游戏池边界        runGame(&amp;tetrisManager, &amp;tetrisControl);  // 运行游戏        if (ifPlayAgain())  // 再来一次        {            SetConsoleTextAttribute(g_hConsoleOutput, 0x7);            system(&quot;cls&quot;);  // 清屏            restartGame(&amp;tetrisManager, &amp;tetrisControl);  // 重新开始游戏        } else {            break;        }    } while (1);    gotoxyWithFullwidth(0, 0);    CloseHandle(g_hConsoleOutput);    return 0;}// =============================================================================// 初始化游戏void initGame(TetrisManager *manager, TetrisControl *control) {    CONSOLE_CURSOR_INFO cursorInfo = { 1, FALSE };  // 光标信息    g_hConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);  // 获取控制台输出句柄    SetConsoleCursorInfo(g_hConsoleOutput, &amp;cursorInfo);  // 设置光标隐藏    SetConsoleTitleA(&quot;俄罗斯方块&quot;);    restartGame(manager, control);}// =============================================================================// 重新开始游戏void restartGame(TetrisManager *manager, TetrisControl *control) {    memset(manager, 0, sizeof(TetrisManager));  // 全部置0    // 初始化游戏池    memcpy(manager-&gt;pool, gs_uInitialTetrisPool, sizeof(uint16_t[28]));    srand((unsigned) time(NULL ));  // 设置随机种子    manager-&gt;type[1] = rand() % 7;  // 下一个    manager-&gt;orientation[1] = rand() &amp; 3;    manager-&gt;type[2] = rand() % 7;  // 下下一个    manager-&gt;orientation[2] = rand() &amp; 3;    memset(control, 0, sizeof(TetrisControl));  // 全部置0    giveTetris(manager);  // 给下一个方块    setPoolColor(manager, control);  // 设置颜色}// =============================================================================// 给一个方块void giveTetris(TetrisManager *manager) {    uint16_t tetris;    manager-&gt;type[0] = manager-&gt;type[1];  // 下一个方块置为当前    manager-&gt;orientation[0] = manager-&gt;orientation[1];    manager-&gt;type[1] = manager-&gt;type[2];  // 下下一个置方块为下一个    manager-&gt;orientation[1] = manager-&gt;orientation[2];    manager-&gt;type[2] = rand() % 7;  // 随机生成下下一个方块    manager-&gt;orientation[2] = rand() &amp; 3;    tetris = gs_uTetrisTable[manager-&gt;type[0]][manager-&gt;orientation[0]]; // 当前方块    // 设置当前方块y坐标，保证刚给出时只显示方块最下面一行    // 这种实现使得玩家可以以很快的速度将方块落在不显示出来的顶部4行内    if (tetris &amp; 0xF000) {        manager-&gt;y = 0;    } else {        manager-&gt;y = (tetris &amp; 0xFF00) ? 1 : 2;    }    manager-&gt;x = 6;  // 设置当前方块x坐标    if (checkCollision(manager))  // 检测到碰撞            {        manager-&gt;dead = true;  // 标记游戏结束    } else  // 未检测到碰撞    {        insertTetris(manager);  // 将当前方块加入游戏池    }    ++manager-&gt;tetrisTotal;  // 方块总数    ++manager-&gt;tetrisCount[manager-&gt;type[0]];  // 相应方块数    printNextTetris(manager);  // 显示下一个方块    printScore(manager);  // 显示得分信息}// =============================================================================// 碰撞检测bool checkCollision(const TetrisManager *manager) {    // 当前方块    uint16_t tetris = gs_uTetrisTable[manager-&gt;type[0]][manager-&gt;orientation[0]];    uint16_t dest = 0;    // 获取当前方块在游戏池中的区域：    // 游戏池坐标x y处小方格信息，按低到高存放在16位无符号数中    dest |= (((manager-&gt;pool[manager-&gt;y + 0] &gt;&gt; manager-&gt;x) &lt;&lt; 0x0) &amp; 0x000F);    dest |= (((manager-&gt;pool[manager-&gt;y + 1] &gt;&gt; manager-&gt;x) &lt;&lt; 0x4) &amp; 0x00F0);    dest |= (((manager-&gt;pool[manager-&gt;y + 2] &gt;&gt; manager-&gt;x) &lt;&lt; 0x8) &amp; 0x0F00);    dest |= (((manager-&gt;pool[manager-&gt;y + 3] &gt;&gt; manager-&gt;x) &lt;&lt; 0xC) &amp; 0xF000);    // 若当前方块与目标区域存在重叠（碰撞），则位与的结果不为0    return ((dest &amp; tetris) != 0);}// =============================================================================// 插入方块void insertTetris(TetrisManager *manager) {    // 当前方块    uint16_t tetris = gs_uTetrisTable[manager-&gt;type[0]][manager-&gt;orientation[0]];    // 当前方块每4位取出，位或到游戏池相应位置，即完成插入方块    manager-&gt;pool[manager-&gt;y + 0] |= (((tetris &gt;&gt; 0x0) &amp; 0x000F) &lt;&lt; manager-&gt;x);    manager-&gt;pool[manager-&gt;y + 1] |= (((tetris &gt;&gt; 0x4) &amp; 0x000F) &lt;&lt; manager-&gt;x);    manager-&gt;pool[manager-&gt;y + 2] |= (((tetris &gt;&gt; 0x8) &amp; 0x000F) &lt;&lt; manager-&gt;x);    manager-&gt;pool[manager-&gt;y + 3] |= (((tetris &gt;&gt; 0xC) &amp; 0x000F) &lt;&lt; manager-&gt;x);}// =============================================================================// 移除方块void removeTetris(TetrisManager *manager) {    // 当前方块    uint16_t tetris = gs_uTetrisTable[manager-&gt;type[0]][manager-&gt;orientation[0]];    // 当前方块每4位取出，按位取反后位与到游戏池相应位置，即完成移除方块    manager-&gt;pool[manager-&gt;y + 0] &amp;=            ~(((tetris &gt;&gt; 0x0) &amp; 0x000F) &lt;&lt; manager-&gt;x);    manager-&gt;pool[manager-&gt;y + 1] &amp;=            ~(((tetris &gt;&gt; 0x4) &amp; 0x000F) &lt;&lt; manager-&gt;x);    manager-&gt;pool[manager-&gt;y + 2] &amp;=            ~(((tetris &gt;&gt; 0x8) &amp; 0x000F) &lt;&lt; manager-&gt;x);    manager-&gt;pool[manager-&gt;y + 3] &amp;=            ~(((tetris &gt;&gt; 0xC) &amp; 0x000F) &lt;&lt; manager-&gt;x);}// =============================================================================// 设置颜色void setPoolColor(const TetrisManager *manager, TetrisControl *control) {    // 由于显示游戏池时，先要在游戏池里判断某一方格有方块才显示相应方格的颜色    // 这里只作设置即可，没必要清除    // 当移动方块或给一个方块时调用    int8_t i, x, y;    // 当前方块    uint16_t tetris = gs_uTetrisTable[manager-&gt;type[0]][manager-&gt;orientation[0]];    for (i = 0; i &lt; 16; ++i) {        y = (i &gt;&gt; 2) + manager-&gt;y;  // 待设置的列        if (y &gt; ROW_END)  // 超过底部限制        {            break;        }        x = (i &amp; 3) + manager-&gt;x;  // 待设置的行        if ((tetris &gt;&gt; i) &amp; 1)  // 检测的到小方格属于当前方块区域                {            control-&gt;color[y][x] = (manager-&gt;type[0] | 8);  // 设置颜色        }    }}// =============================================================================// 旋转方块void rotateTetris(TetrisManager *manager, TetrisControl *control) {    int8_t ori = manager-&gt;orientation[0];  // 记录原旋转状态    removeTetris(manager);  // 移走当前方块    // 顺/逆时针旋转    manager-&gt;orientation[0] =            (control-&gt;clockwise) ? ((ori + 1) &amp; 3) : ((ori + 3) &amp; 3);    if (checkCollision(manager))  // 检测到碰撞            {        manager-&gt;orientation[0] = ori;  // 恢复为原旋转状态        insertTetris(manager);  // 放入当前方块。由于状态没改变，不需要设置颜色    } else {        insertTetris(manager);  // 放入当前方块        setPoolColor(manager, control);  // 设置颜色        printCurrentTetris(manager, control);  // 显示当前方块    }}// =============================================================================// 水平移动方块void horzMoveTetris(TetrisManager *manager, TetrisControl *control) {    int x = manager-&gt;x;  // 记录原列位置    removeTetris(manager);  // 移走当前方块    control-&gt;direction == 0 ? (--manager-&gt;x) : (++manager-&gt;x);  // 左/右移动    if (checkCollision(manager))  // 检测到碰撞            {        manager-&gt;x = x;  // 恢复为原列位置        insertTetris(manager);  // 放入当前方块。由于位置没改变，不需要设置颜色    } else {        insertTetris(manager);  // 放入当前方块        setPoolColor(manager, control);  // 设置颜色        printCurrentTetris(manager, control);  // 显示当前方块    }}// =============================================================================// 向下移动方块void moveDownTetris(TetrisManager *manager, TetrisControl *control) {    int8_t y = manager-&gt;y;  // 记录原行位置    removeTetris(manager);  // 移走当前方块    ++manager-&gt;y;  // 向下移动    if (checkCollision(manager))  // 检测到碰撞            {        manager-&gt;y = y;  // 恢复为原行位置        insertTetris(manager);  // 放入当前方块。由于位置没改变，不需要设置颜色        if (checkErasing(manager, control))  // 检测到消行                {            printTetrisPool(manager, control);  // 显示游戏池        }    } else {        insertTetris(manager);  // 放入当前方块        setPoolColor(manager, control);  // 设置颜色        printCurrentTetris(manager, control);  // 显示当前方块    }}// =============================================================================// 方块直接落地void dropDownTetris(TetrisManager *manager, TetrisControl *control) {    removeTetris(manager);  // 移走当前方块    for (; manager-&gt;y &lt; ROW_END; ++manager-&gt;y)  // 从上往下            {        if (checkCollision(manager))  // 检测到碰撞                {            break;        }    }    --manager-&gt;y;  // 上移一格当然没有碰撞    insertTetris(manager);  // 放入当前方块    setPoolColor(manager, control);  // 设置颜色    checkErasing(manager, control);  // 检测消行    printTetrisPool(manager, control);  // 显示游戏池}// =============================================================================// 消行检测bool checkErasing(TetrisManager *manager, TetrisControl *control) {    static const unsigned scores[5] = { 0, 10, 30, 90, 150 };  // 消行得分    int8_t count = 0;    int8_t k = 0, y = manager-&gt;y + 3;  // 从下往上检测    do {        if (y &lt; ROW_END &amp;&amp; manager-&gt;pool[y] == 0xFFFFU)  // 有效区域内且一行已填满                {            ++count;            // 消除一行方块            memmove(manager-&gt;pool + 1, manager-&gt;pool, sizeof(uint16_t) * y);            // 颜色数组的元素随之移动            memmove(control-&gt;color[1], control-&gt;color[0],                    sizeof(int8_t[16]) * y);        } else {            --y;            ++k;        }    } while (y &gt;= manager-&gt;y &amp;&amp; k &lt; 4);    manager-&gt;erasedTotal += count;  // 消行总数    manager-&gt;score += scores[count];  // 得分    if (count &gt; 0) {        ++manager-&gt;erasedCount[count - 1];  // 消行    }    giveTetris(manager);  // 给下一个方块    setPoolColor(manager, control);  // 设置颜色    return (count &gt; 0);}// =============================================================================// 键按下void keydownControl(TetrisManager *manager, TetrisControl *control, int key) {    if (key == 13)  // 暂停/解除暂停            {        control-&gt;pause = !control-&gt;pause;    }    if (control-&gt;pause)  // 暂停状态，不作处理    {        return;    }    switch (key) {    case &#39;w&#39;:    case &#39;W&#39;:    case &#39;8&#39;:    case 72:  // 上        control-&gt;clockwise = true;  // 顺时针旋转        rotateTetris(manager, control);  // 旋转方块        break;    case &#39;a&#39;:    case &#39;A&#39;:    case &#39;4&#39;:    case 75:  // 左        control-&gt;direction = 0;  // 向左移动        horzMoveTetris(manager, control);  // 水平移动方块        break;    case &#39;d&#39;:    case &#39;D&#39;:    case &#39;6&#39;:    case 77:  // 右        control-&gt;direction = 1;  // 向右移动        horzMoveTetris(manager, control);  // 水平移动方块        break;    case &#39;s&#39;:    case &#39;S&#39;:    case &#39;2&#39;:    case 80:  // 下        moveDownTetris(manager, control);  // 向下移动方块        break;    case &#39; &#39;:  // 直接落地        dropDownTetris(manager, control);        break;    case &#39;0&#39;:  // 反转        control-&gt;clockwise = false;  // 逆时针旋转        rotateTetris(manager, control);  // 旋转方块        break;    default:        break;    }}// =============================================================================// 以全角定位void gotoxyWithFullwidth(short x, short y) {    static COORD cd;    cd.X = (short) (x &lt;&lt; 1);    cd.Y = y;    SetConsoleCursorPosition(g_hConsoleOutput, cd);}// =============================================================================// 显示游戏池边界void printPoolBorder() {    int8_t y;    SetConsoleTextAttribute(g_hConsoleOutput, 0xF0);    for (y = ROW_BEGIN; y &lt; ROW_END; ++y)  // 不显示顶部4行和底部2行            {        gotoxyWithFullwidth(10, y - 3);        printf(&quot;%2s&quot;, &quot;&quot;);        gotoxyWithFullwidth(23, y - 3);        printf(&quot;%2s&quot;, &quot;&quot;);    }    gotoxyWithFullwidth(10, y - 3);  // 底部边界    printf(&quot;%28s&quot;, &quot;&quot;);}// 定位到游戏池中的方格#define gotoxyInPool(x, y) gotoxyWithFullwidth(x + 9, y - 3)// =============================================================================// 显示游戏池void printTetrisPool(const TetrisManager *manager, const TetrisControl *control) {    int8_t x, y;    for (y = ROW_BEGIN; y &lt; ROW_END; ++y)  // 不显示顶部4行和底部2行            {        gotoxyInPool(2, y);        // 定点到游戏池中的方格        for (x = COL_BEGIN; x &lt; COL_END; ++x)  // 不显示左右边界                {            if ((manager-&gt;pool[y] &gt;&gt; x) &amp; 1)  // 游戏池该方格有方块                    {                // 用相应颜色，显示一个实心方块                SetConsoleTextAttribute(g_hConsoleOutput, control-&gt;color[y][x]);                printf(&quot;■&quot;);            } else  // 没有方块，显示空白            {                SetConsoleTextAttribute(g_hConsoleOutput, 0);                printf(&quot;%2s&quot;, &quot;&quot;);            }        }    }}// =============================================================================// 显示当前方块void printCurrentTetris(const TetrisManager *manager,        const TetrisControl *control) {    int8_t x, y;    // 显示当前方块是在移动后调用的，为擦去移动前的方块，需要扩展显示区域    // 由于不可能向上移动，故不需要向下扩展    y = (manager-&gt;y &gt; ROW_BEGIN) ? (manager-&gt;y - 1) : ROW_BEGIN;  // 向上扩展一格    for (; y &lt; ROW_END &amp;&amp; y &lt; manager-&gt;y + 4; ++y) {        x = (manager-&gt;x &gt; COL_BEGIN) ? (manager-&gt;x - 1) : COL_BEGIN;  // 向左扩展一格        for (; x &lt; COL_END &amp;&amp; x &lt; manager-&gt;x + 5; ++x)  // 向右扩展一格                {            gotoxyInPool(x, y);            // 定点到游戏池中的方格            if ((manager-&gt;pool[y] &gt;&gt; x) &amp; 1)  // 游戏池该方格有方块                    {                // 用相应颜色，显示一个实心方块                SetConsoleTextAttribute(g_hConsoleOutput, control-&gt;color[y][x]);                printf(&quot;■&quot;);            } else  // 没有方块，显示空白            {                SetConsoleTextAttribute(g_hConsoleOutput, 0);                printf(&quot;%2s&quot;, &quot;&quot;);            }        }    }}// =============================================================================// 显示下一个和下下一个方块void printNextTetris(const TetrisManager *manager) {    int8_t i;    uint16_t tetris;    // 边框    SetConsoleTextAttribute(g_hConsoleOutput, 0xF);    gotoxyWithFullwidth(26, 1);    printf(&quot;┏━━━━┳━━━━┓&quot;);    gotoxyWithFullwidth(26, 2);    printf(&quot;┃%8s┃%8s┃&quot;, &quot;&quot;, &quot;&quot;);    gotoxyWithFullwidth(26, 3);    printf(&quot;┃%8s┃%8s┃&quot;, &quot;&quot;, &quot;&quot;);    gotoxyWithFullwidth(26, 4);    printf(&quot;┃%8s┃%8s┃&quot;, &quot;&quot;, &quot;&quot;);    gotoxyWithFullwidth(26, 5);    printf(&quot;┃%8s┃%8s┃&quot;, &quot;&quot;, &quot;&quot;);    gotoxyWithFullwidth(26, 6);    printf(&quot;┗━━━━┻━━━━┛&quot;);    // 下一个，用相应颜色显示    tetris = gs_uTetrisTable[manager-&gt;type[1]][manager-&gt;orientation[1]];    SetConsoleTextAttribute(g_hConsoleOutput, manager-&gt;type[1] | 8);    for (i = 0; i &lt; 16; ++i) {        gotoxyWithFullwidth((i &amp; 3) + 27, (i &gt;&gt; 2) + 2);        ((tetris &gt;&gt; i) &amp; 1) ? printf(&quot;■&quot;) : printf(&quot;%2s&quot;, &quot;&quot;);    }    // 下下一个，不显示彩色    tetris = gs_uTetrisTable[manager-&gt;type[2]][manager-&gt;orientation[2]];    SetConsoleTextAttribute(g_hConsoleOutput, 8);    for (i = 0; i &lt; 16; ++i) {        gotoxyWithFullwidth((i &amp; 3) + 32, (i &gt;&gt; 2) + 2);        ((tetris &gt;&gt; i) &amp; 1) ? printf(&quot;■&quot;) : printf(&quot;%2s&quot;, &quot;&quot;);    }}// =============================================================================// 显示得分信息void printScore(const TetrisManager *manager) {    static const char *tetrisName = &quot;ITLJZSO&quot;;    int8_t i;    SetConsoleTextAttribute(g_hConsoleOutput, 0xE);    gotoxyWithFullwidth(2, 2);    printf(&quot;■得分：%u&quot;, manager-&gt;score);    gotoxyWithFullwidth(1, 6);    printf(&quot;■消行总数：%u&quot;, manager-&gt;erasedTotal);    for (i = 0; i &lt; 4; ++i) {        gotoxyWithFullwidth(2, 8 + i);        printf(&quot;□消%d：%u&quot;, i + 1, manager-&gt;erasedCount[i]);    }    gotoxyWithFullwidth(1, 15);    printf(&quot;■方块总数：%u&quot;, manager-&gt;tetrisTotal);    for (i = 0; i &lt; 7; ++i) {        gotoxyWithFullwidth(2, 17 + i);        printf(&quot;□%c形：%u&quot;, tetrisName[i], manager-&gt;tetrisCount[i]);    }}// =============================================================================// 显示提示信息void printPrompting() {    SetConsoleTextAttribute(g_hConsoleOutput, 0xB);    gotoxyWithFullwidth(26, 10);    printf(&quot;■控制：&quot;);    gotoxyWithFullwidth(27, 12);    printf(&quot;□向左移动：← A 4&quot;);    gotoxyWithFullwidth(27, 13);    printf(&quot;□向右移动：→ D 6&quot;);    gotoxyWithFullwidth(27, 14);    printf(&quot;□向下移动：↓ S 2&quot;);    gotoxyWithFullwidth(27, 15);    printf(&quot;□顺时针转：↑ W 8&quot;);    gotoxyWithFullwidth(27, 16);    printf(&quot;□逆时针转：0&quot;);    gotoxyWithFullwidth(27, 17);    printf(&quot;□直接落地：空格&quot;);    gotoxyWithFullwidth(27, 18);    printf(&quot;□暂停游戏：回车&quot;);    gotoxyWithFullwidth(25, 23);    printf(&quot;■By: wohaaitinciu 12.12.29&quot;);}// =============================================================================// 运行游戏void runGame(TetrisManager *manager, TetrisControl *control) {    clock_t clockLast, clockNow;    clockLast = clock();  // 计时    printTetrisPool(manager, control);  // 显示游戏池    while (!manager-&gt;dead)  // 没挂    {        while (_kbhit())  // 有键按下        {            keydownControl(manager, control, _getch());  // 处理按键        }        if (!control-&gt;pause)  // 未暂停        {            clockNow = clock();  // 计时            // 两次记时的间隔超过0.45秒            if (clockNow - clockLast &gt; 0.45F * CLOCKS_PER_SEC ) {                clockLast = clockNow;                keydownControl(manager, control, 80);  // 方块往下移            }        }    }}// =============================================================================// 再来一次bool ifPlayAgain() {    int ch;    SetConsoleTextAttribute(g_hConsoleOutput, 0xF0);    gotoxyWithFullwidth(15, 10);    printf(&quot;游戏结束&quot;);    gotoxyWithFullwidth(13, 11);    printf(&quot;按Y重玩，按N退出&quot;);    do {        ch = _getch();        if (ch == &#39;Y&#39; || ch == &#39;y&#39;) {            return true;        } else if (ch == &#39;N&#39; || ch == &#39;n&#39;) {            return false;        }    } while (1);}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文代码下载地址: &lt;a href=&quot;/download/俄罗斯方块.zip&quot;&gt;俄罗斯方块.c&lt;/a&gt;&lt;br&gt;本文程序下载地址: &lt;a href=&quot;/download/俄罗斯方块.exe&quot;&gt;俄罗斯方块.exe&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;#in
      
    
    </summary>
    
      <category term="Game" scheme="http://www.icharles.top/categories/Game/"/>
    
    
      <category term="Game" scheme="http://www.icharles.top/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>欧几里得算法</title>
    <link href="http://www.icharles.top/2017/12/27/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    <id>http://www.icharles.top/2017/12/27/欧几里得算法/</id>
    <published>2017-12-27T08:29:00.000Z</published>
    <updated>2018-01-16T10:18:14.794Z</updated>
    
    <content type="html"><![CDATA[<p><strong>欧几里得算法</strong>计算的是两个自然数a和b的最大公约数，两个数的最大公约数通常写成gcd(a, b)，如果有gcd(a, b)==1，则有a，b互质。</p><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><ul><li>递归<pre><code class="c">int Gcd(int a, int b){  if(b == 0)      return a;  return Gcd(b, a % b);}</code></pre></li><li>迭代<pre><code class="c">int Gcd(int a, int b){  while(b != 0)  {      int r = b;      b = a % b;      a = r;  }  return a;}</code></pre></li></ul><h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><ul><li>介绍<br><strong>扩展欧几里德算法</strong>是用来在已知a, b求解一组p，q使得p<em>a+q</em>b=Gcd(a,b)(根据数论中的相关定理解一定存在，不展开叙述)。扩展欧几里德常用在求解模线性方程及方程组中。        </li><li><p>算法</p><pre><code class="C">int exGcd(int a, int b, int &amp;x, int &amp;y){  if(b == 0)  {      x = 1;      y = 0;      return a;  }  int r = exGcd(b, a % b, x, y);  int t = x;  x = y;  y = t - a / b * y;  return r;}</code></pre></li><li>理解<br>把这个实现和Gcd的递归实现相比，发现多了下面的x,y赋值过程，这就是扩展欧几里德算法的精髓。 可以这样思考: 对于a’ =b , b’ =a%b 而言，我们求得x, y使得a’ x+b’ y=Gcd(a’, b’) 由于b’ = a % b = a - a / b <em> b 那么可以得到 :<br>a’ x + b’ y = Gcd(a’ , b’)<br>===&gt;<br>bx + (a - a/b </em>b)y = Gcd(a’ , b’) = Gcd(a, b)  //注意到这里的/是C语言中的出发<br>===&gt;<br>ay + b(x- a/b <em>y) = Gcd(a, b)<br>因此对于a和b而言，他们的相对应的p，q分别是 y和(x-a/b</em>y)</li></ul><p><a href="https://my.oschina.net/u/1780798/blog/646739" target="_blank" rel="noopener">推荐文章 ：https://my.oschina.net/u/1780798/blog/646739</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;欧几里得算法&lt;/strong&gt;计算的是两个自然数a和b的最大公约数，两个数的最大公约数通常写成gcd(a, b)，如果有gcd(a, b)==1，则有a，b互质。&lt;/p&gt;
&lt;h3 id=&quot;欧几里得算法&quot;&gt;&lt;a href=&quot;#欧几里得算法&quot; class=&quot;he
      
    
    </summary>
    
      <category term="算法" scheme="http://www.icharles.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.icharles.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Vector--STL</title>
    <link href="http://www.icharles.top/2017/12/27/Vector-STL/"/>
    <id>http://www.icharles.top/2017/12/27/Vector-STL/</id>
    <published>2017-12-27T08:27:00.000Z</published>
    <updated>2018-01-16T10:13:23.521Z</updated>
    
    <content type="html"><![CDATA[<p><strong>vector(向量)</strong><br>vector类称作向量类，它实现了动态数组，用于元素数量变化的对象数组。像数组一样，vector类也用从0开始的下标表示元素的位置；但和数组不同的是，当vector对象创建后，数组的元素个数会随着vector对象元素个数的增大和缩小而自动变化。<br>用法:</p><pre><code class="c">#include&lt;vector&gt;using namespace std;vector &lt;int &gt; aint b = 5;a.push_back(b); //该函数下面有详解cout&lt;&lt;a[0];        //输出结果为5</code></pre><table><thead><tr><th>函数</th><th>动作</th></tr></thead><tbody><tr><td>push_back</td><td>在数组的最后添加一个数据</td></tr><tr><td>pop_back</td><td>去掉数组的最后一个数据</td></tr><tr><td>at</td><td>得到编号位置的数据</td></tr><tr><td>begin</td><td>得到数组头的指针</td></tr><tr><td>end</td><td>得到数组的最后一个单元+1的指针</td></tr><tr><td>front</td><td>得到数组头的引用</td></tr><tr><td>back</td><td>得到数组的最后一个单元的引用</td></tr><tr><td>max_size</td><td>得到vector最大可以是多大</td></tr><tr><td>capacity</td><td>当前vector分配的大小</td></tr><tr><td>size</td><td>当前使用数据的大小</td></tr><tr><td>resize</td><td>改变当前使用数据的大小，如果它比当前使用的大，者填充默认值</td></tr><tr><td>reserve</td><td>改变当前vecotr所分配空间的大小</td></tr><tr><td>erase</td><td>删除指针指向的数据项</td></tr><tr><td>clear</td><td>清空当前的vector</td></tr><tr><td>rbegin</td><td>将vector反转后的开始指针返回(其实就是原来的end-1)</td></tr><tr><td>rend</td><td>将vector反转构的结束指针返回(其实就是原来的begin-1)</td></tr><tr><td>empty</td><td>判断vector是否为空</td></tr><tr><td>swap</td><td>与另一个vector交换数据</td></tr></tbody></table><p>详细的函数实现功能 ：<br>其中  vector &lt;int&gt; c  </p><table><thead><tr><th>函数</th><th>动作</th></tr></thead><tbody><tr><td>c.clear()</td><td>移除容器中所有元素。</td></tr><tr><td>c.empty()</td><td>判断容器是否为空。</td></tr><tr><td>c.erase(pos)</td><td>删除pos位置之后的一个元素</td></tr><tr><td>c.erase(begin,end)</td><td>删除[begin,end)区间的元素</td></tr><tr><td>c.front()</td><td>传回第一个元素</td></tr><tr><td>c.insert(pos,elem)</td><td>在pos位置之后插入一个elem拷贝</td></tr><tr><td>c.pop_back()</td><td>删除最后一个元素</td></tr><tr><td>c.push_back(elem)</td><td>在尾部加入一个元素</td></tr><tr><td>c.resize(num)</td><td>重新设置该容器的大小</td></tr><tr><td>c.size()</td><td>回容器中元素的个数</td></tr><tr><td>c.begin()</td><td>返回指向容器第一个元素的迭代器</td></tr><tr><td>c.end()</td><td>返回指向容器最后一个元素的迭代器</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;vector(向量)&lt;/strong&gt;&lt;br&gt;vector类称作向量类，它实现了动态数组，用于元素数量变化的对象数组。像数组一样，vector类也用从0开始的下标表示元素的位置；但和数组不同的是，当vector对象创建后，数组的元素个数会随着vector对象
      
    
    </summary>
    
      <category term="STL" scheme="http://www.icharles.top/categories/STL/"/>
    
    
      <category term="STL" scheme="http://www.icharles.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>位运算技巧</title>
    <link href="http://www.icharles.top/2017/12/26/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.icharles.top/2017/12/26/位运算技巧/</id>
    <published>2017-12-26T10:03:00.000Z</published>
    <updated>2017-12-27T13:24:18.970Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一.获得int型最大值</strong><br>代码代码如下:</p><pre><code class="c">int getMaxInt() {      return (1&lt;&lt;31) - 1;    //2147483647， 由于优先级关系，括号不可省略}</code></pre><p>另一种写法<br>代码代码如下:</p><pre><code class="c">int getMaxInt() {      return -(1&lt;&lt;-1) - 1;    //2147483647  }</code></pre><p>另一种写法<br>代码代码如下:</p><pre><code class="c">int getMaxInt() {      return ~(1&lt;&lt;31);//2147483647  }</code></pre><p>C语言中不知道int占几个字节时候<br>代码代码如下:</p><pre><code class="c">int getMaxInt(){      return ((unsigned int)-1) &gt;&gt; 1;//2147483647  }</code></pre><p><strong>二.获得int型最小值</strong><br>复制代码代码如下:</p><pre><code class="c">int getMinInt() {      return 1&lt;&lt;31;    //-2147483648   }</code></pre><p>另一种写法<br>代码代码如下:</p><pre><code class="c">int getMinInt(){      return 1 &lt;&lt; -1;//-2147483648  }</code></pre><p><strong>三.获得long类型的最大值</strong><br>C语言版<br>代码代码如下:</p><pre><code class="c">long getMaxLong() {      return ((unsigned long)-1) &gt;&gt; 1;    //2147483647  }</code></pre><p>JAVA版<br>代码代码如下:</p><pre><code class="java">long getMaxLong() {      return ((long)1&lt;&lt;127)-1;    //9223372036854775807  }</code></pre><p>获得long最小值，和其他类型的最大值，最小值同理.   </p><p><strong>四.乘以2运算</strong><br>代码代码如下:</p><pre><code class="c">int mulTwo(int n) {    //计算n*2       return n&lt;&lt;1;  }</code></pre><p><strong>五.除以2运算</strong><br>代码代码如下:  </p><pre><code class="c">int divTwo(int n) {    //负奇数的运算不可用      return n&gt;&gt;1;    //除以2  }</code></pre><p><strong>六.乘以2的m次方</strong><br>代码代码如下:</p><pre><code class="c">int divTwoPower(int n,int m){    //计算n/(2^m)      return n&gt;&gt;m;  }</code></pre><p><strong>七.除以2的m次方</strong><br>代码代码如下:</p><pre><code class="c">int divTwoPower(int n,int m) {    //计算n/(2^m)      return n&gt;&gt;m;  }</code></pre><p><strong>八.判断一个数的奇偶性</strong><br>代码代码如下:</p><pre><code class="c">boolean isOddNumber(int n) {      return (n &amp; 1) == 1;  }</code></pre><p><strong>九.不用临时变量交换两个数</strong><br>C语言版<br>代码代码如下:</p><pre><code class="c">void swap(int *a,int *b) {         (*a)^=(*b)^=(*a)^=(*b);   }</code></pre><p>通用版（一些语言中得分开写）<br>代码代码如下:</p><pre><code class="c">a ^= b;  b ^= a;  a ^= b;</code></pre><p><strong>十.取绝对值</strong><br>代码代码如下:</p><pre><code class="c">int abs(int n){      return (n ^ (n &gt;&gt; 31)) - (n &gt;&gt; 31);   }/* n&gt;&gt;31 取得n的符号，若n为正数，n&gt;&gt;31等于0，若n为负数，n&gt;&gt;31等于-1 若n为正数 n^0=0,数不变，若n为负数有n^-1 需要计算n和-1的补码，然后进行异或运算， 结果n变号并且为n的绝对值减1，再减去-1就是绝对值 */</code></pre><p><strong>十一.取两个数的最大值</strong><br>通用版<br>复制代码代码如下:</p><pre><code class="c">int max(int a,int b) {      return b&amp;((a-b)&gt;&gt;31) | a&amp;(~(a-b)&gt;&gt;31);      // 如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1}</code></pre><p>C语言版<br>代码代码如下:</p><pre><code class="c">int max(int x,int y) {      return x ^ ((x ^ y) &amp; -(x &lt; y));      /*如果x&lt;y x&lt;y返回1，否则返回0， 与0做与运算结果为0，与-1做与运算结果不变*/  }</code></pre><p><strong>十二.取两个数的最小值</strong><br>通用版<br>代码代码如下:</p><pre><code class="c">int min(int a,int b) {      return a&amp;((a-b)&gt;&gt;31) | b&amp;(~(a-b)&gt;&gt;31);      // 如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1 }</code></pre><p>C语言版<br>代码代码如下:</p><pre><code class="c">int min(int x,int y) {      return y ^ ((x ^ y) &amp; -(x &lt; y));          // 如果x&lt;y x&lt;y返回1，否则返回0，         // 与0做与运算结果为0，与-1做与运算结果不变}</code></pre><p><strong>十三.判断符号是否相同</strong><br>代码如下:</p><pre><code class="c">boolean isSameSign(int x, int y) {      return (x ^ y) &gt; 0;     // true 表示 x和y有相同的符号， false表示x，y有相反的符号。  }</code></pre><p><strong>十四.计算2的n次方</strong><br>代码代码如下:</p><pre><code class="c">int getFactorialofTwo(int n) {    //n &gt; 0      return 2&lt;&lt;(n-1);        //2的n次方  }</code></pre><p><strong>十五.判断一个数是不是2的幂</strong><br>代码代码如下:</p><pre><code class="c">boolean isFactorialofTwo(int n) {      return (n &amp; (n - 1)) == 0;      // 如果是2的幂，n一定是100... n-1就是1111....     // 所以做与运算结果为0 }</code></pre><p><strong>十六.对2的n次方取余</strong><br>代码代码如下:</p><pre><code class="c">int quyu(int m,int n) {    //n为2的次方      return m &amp; (n - 1);      // 如果是2的幂，n一定是100... n-1就是1111....     // 所以做与运算结果保留m在n范围的非0的位}</code></pre><p><strong>十七.求两个整数的平均值</strong><br>代码代码如下:</p><pre><code class="c">int getAverage(int x, int y) {          return (x+y) &gt;&gt; 1;   ｝</code></pre><p>另一种写法<br>代码代码如下:</p><pre><code class="c">int getAverage(int x, int y) {          return ((x^y) &gt;&gt; 1) + (x&amp;y);        // (x^y) &gt;&gt; 1得到x，y其中一个为1的位并除以2，      // x&amp;y得到x，y都为1的部分，加一起就是平均数了 }</code></pre><p>下面是三个最基本对二进制位的操作<br><strong>十八.从低位到高位,取n的第m位</strong><br>代码代码如下:</p><pre><code class="c">int getBit(int n, int m) {      return (n &gt;&gt; (m-1)) &amp; 1;  }</code></pre><p><strong>十九.从低位到高位.将n的第m位置1</strong><br>代码代码如下:</p><pre><code class="c">int setBitToOne(int n, int m) {      return n | (1&lt;&lt;(m-1));      // 将1左移m-1位找到第m位，得到000...1...000     // n在和这个数做或运算}</code></pre><p><strong>二十.从低位到高位,将n的第m位置0</strong><br>代码代码如下:</p><pre><code class="c">int setBitToZero(int n, int m) {      return n &amp; ~(1&lt;&lt;(m-1));      // 将1左移m-1位找到第m位，取反后变成111...0...1111     // n再和这个数做与运算 }</code></pre><p>另附一些对程序效率上没有实质提高的位运算技巧，一些也是位运算的常识（面试也许会遇到）<br>计算n+1<br>代码代码如下:</p><pre><code class="c">-~n</code></pre><p>计算n-1<br>代码代码如下:</p><pre><code class="c">~-n</code></pre><p>取相反数<br>代码代码如下:</p><pre><code class="c">~n + 1;</code></pre><p>另一种写法<br>代码代码如下:</p><pre><code class="c">(n ^ -1) + 1;  if(x == a) x = b; if(x == b) x = a;</code></pre><p>代码代码如下:</p><pre><code class="c">x = a ^ b ^ x;</code></pre><p>sign函数，参数为n，当n&gt;0时候返回1，n&lt;0时返回-1，n=0时返回0<br>复制代码代码如下:</p><pre><code class="c">return !!n - (((unsigned)n&gt;&gt;31)&lt;&lt;1);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一.获得int型最大值&lt;/strong&gt;&lt;br&gt;代码代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int getMaxInt() {  
    return (1&amp;lt;&amp;lt;31) - 1;    //2147483647， 由于优先级
      
    
    </summary>
    
      <category term="位运算" scheme="http://www.icharles.top/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
      <category term="ACM" scheme="http://www.icharles.top/tags/ACM/"/>
    
  </entry>
  
</feed>

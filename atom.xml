<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Charles</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-27T13:20:40.664Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Charles</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>欧几里得算法</title>
    <link href="http://yoursite.com/2017/12/27/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2017/12/27/欧几里得算法/</id>
    <published>2017-12-27T08:29:00.000Z</published>
    <updated>2017-12-27T13:20:40.664Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我的个人博客：地址"><a href="#我的个人博客：地址" class="headerlink" title="我的个人博客：地址"></a>我的个人博客：<a href="http://www.icharles.top/2017/12/15/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">地址</a></h3><p><strong>欧几里得算法</strong>计算的是两个自然数a和b的最大公约数，两个数的最大公约数通常写成gcd(a, b)，如果有gcd(a, b)==1，则有a，b互质。</p><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><ul><li><p>递归</p><pre><code class="c">int Gcd(int a, int b){  if(b == 0)      return a;  return Gcd(b, a % b);}</code></pre></li><li><p>迭代</p><pre><code class="c">int Gcd(int a, int b){  while(b != 0)  {      int r = b;      b = a % b;      a = r;  }  return a;}</code></pre></li></ul><h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><ul><li><p>介绍<br><strong>扩展欧几里德算法</strong>是用来在已知a, b求解一组p，q使得p<em>a+q</em>b=Gcd(a,b)(根据数论中的相关定理解一定存在，不展开叙述)。扩展欧几里德常用在求解模线性方程及方程组中。</p></li><li><p>算法</p><pre><code class="C">int exGcd(int a, int b, int &amp;x, int &amp;y){  if(b == 0)  {      x = 1;      y = 0;      return a;  }  int r = exGcd(b, a % b, x, y);  int t = x;  x = y;  y = t - a / b * y;  return r;}</code></pre></li><li>理解<br>把这个实现和Gcd的递归实现相比，发现多了下面的x,y赋值过程，这就是扩展欧几里德算法的精髓。 可以这样思考: 对于a’ =b , b’ =a%b 而言，我们求得x, y使得a’ x+b’ y=Gcd(a’, b’) 由于b’ = a % b = a - a / b <em> b 那么可以得到 :<br>a’ x + b’ y = Gcd(a’ , b’)<br>===&gt;<br>bx + (a - a/b </em>b)y = Gcd(a’ , b’) = Gcd(a, b)  //注意到这里的/是C语言中的出发<br>===&gt;<br>ay + b(x- a/b <em>y) = Gcd(a, b)<br>因此对于a和b而言，他们的相对应的p，q分别是 y和(x-a/b</em>y)</li></ul><p><a href="https://my.oschina.net/u/1780798/blog/646739" target="_blank" rel="noopener">推荐文章 ：https://my.oschina.net/u/1780798/blog/646739</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;我的个人博客：地址&quot;&gt;&lt;a href=&quot;#我的个人博客：地址&quot; class=&quot;headerlink&quot; title=&quot;我的个人博客：地址&quot;&gt;&lt;/a&gt;我的个人博客：&lt;a href=&quot;http://www.icharles.top/2017/12/15/%E6%AC%A
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Vector--STL</title>
    <link href="http://yoursite.com/2017/12/27/Vector-STL/"/>
    <id>http://yoursite.com/2017/12/27/Vector-STL/</id>
    <published>2017-12-27T08:27:00.000Z</published>
    <updated>2017-12-27T13:20:28.739Z</updated>
    
    <content type="html"><![CDATA[<p>我的个人博客：  <a href="http://www.icharles.top/2017/12/15/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91STL-Vector/" target="_blank" rel="noopener">地址</a></p><p><strong>vector(向量)</strong><br>vector类称作向量类，它实现了动态数组，用于元素数量变化的对象数组。像数组一样，vector类也用从0开始的下标表示元素的位置；但和数组不同的是，当vector对象创建后，数组的元素个数会随着vector对象元素个数的增大和缩小而自动变化。<br>用法:</p><pre><code class="c">#include&lt;vector&gt;using namespace std;vector &lt;int &gt; aint b = 5;a.push_back(b); //该函数下面有详解cout&lt;&lt;a[0];        //输出结果为5</code></pre><table><thead><tr><th>函数</th><th>动作</th></tr></thead><tbody><tr><td>push_back</td><td>在数组的最后添加一个数据</td></tr><tr><td>pop_back</td><td>去掉数组的最后一个数据</td></tr><tr><td>at</td><td>得到编号位置的数据</td></tr><tr><td>begin</td><td>得到数组头的指针</td></tr><tr><td>end</td><td>得到数组的最后一个单元+1的指针</td></tr><tr><td>front</td><td>得到数组头的引用</td></tr><tr><td>back</td><td>得到数组的最后一个单元的引用</td></tr><tr><td>max_size</td><td>得到vector最大可以是多大</td></tr><tr><td>capacity</td><td>当前vector分配的大小</td></tr><tr><td>size</td><td>当前使用数据的大小</td></tr><tr><td>resize</td><td>改变当前使用数据的大小，如果它比当前使用的大，者填充默认值</td></tr><tr><td>reserve</td><td>改变当前vecotr所分配空间的大小</td></tr><tr><td>erase</td><td>删除指针指向的数据项</td></tr><tr><td>clear</td><td>清空当前的vector</td></tr><tr><td>rbegin</td><td>将vector反转后的开始指针返回(其实就是原来的end-1)</td></tr><tr><td>rend</td><td>将vector反转构的结束指针返回(其实就是原来的begin-1)</td></tr><tr><td>empty</td><td>判断vector是否为空</td></tr><tr><td>swap</td><td>与另一个vector交换数据</td></tr></tbody></table><p>详细的函数实现功能 ：<br>其中  vector &lt;int&gt; c  </p><table><thead><tr><th>函数</th><th>动作</th></tr></thead><tbody><tr><td>c.clear()</td><td>移除容器中所有元素。</td></tr><tr><td>c.empty()</td><td>判断容器是否为空。</td></tr><tr><td>c.erase(pos)</td><td>删除pos位置之后的一个元素</td></tr><tr><td>c.erase(begin,end)</td><td>删除[begin,end)区间的元素</td></tr><tr><td>c.front()</td><td>传回第一个元素</td></tr><tr><td>c.insert(pos,elem)</td><td>在pos位置之后插入一个elem拷贝</td></tr><tr><td>c.pop_back()</td><td>删除最后一个元素</td></tr><tr><td>c.push_back(elem)</td><td>在尾部加入一个元素</td></tr><tr><td>c.resize(num)</td><td>重新设置该容器的大小</td></tr><tr><td>c.size()</td><td>回容器中元素的个数</td></tr><tr><td>c.begin()</td><td>返回指向容器第一个元素的迭代器</td></tr><tr><td>c.end()</td><td>返回指向容器最后一个元素的迭代器</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我的个人博客：  &lt;a href=&quot;http://www.icharles.top/2017/12/15/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91STL-Vector/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;地址&lt;/
      
    
    </summary>
    
      <category term="STL" scheme="http://yoursite.com/categories/STL/"/>
    
    
      <category term="STL" scheme="http://yoursite.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>位运算技巧</title>
    <link href="http://yoursite.com/2017/12/26/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2017/12/26/位运算技巧/</id>
    <published>2017-12-26T10:03:00.000Z</published>
    <updated>2017-12-27T13:24:18.970Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一.获得int型最大值</strong><br>代码代码如下:</p><pre><code class="c">int getMaxInt() {      return (1&lt;&lt;31) - 1;    //2147483647， 由于优先级关系，括号不可省略}</code></pre><p>另一种写法<br>代码代码如下:</p><pre><code class="c">int getMaxInt() {      return -(1&lt;&lt;-1) - 1;    //2147483647  }</code></pre><p>另一种写法<br>代码代码如下:</p><pre><code class="c">int getMaxInt() {      return ~(1&lt;&lt;31);//2147483647  }</code></pre><p>C语言中不知道int占几个字节时候<br>代码代码如下:</p><pre><code class="c">int getMaxInt(){      return ((unsigned int)-1) &gt;&gt; 1;//2147483647  }</code></pre><p><strong>二.获得int型最小值</strong><br>复制代码代码如下:</p><pre><code class="c">int getMinInt() {      return 1&lt;&lt;31;    //-2147483648   }</code></pre><p>另一种写法<br>代码代码如下:</p><pre><code class="c">int getMinInt(){      return 1 &lt;&lt; -1;//-2147483648  }</code></pre><p><strong>三.获得long类型的最大值</strong><br>C语言版<br>代码代码如下:</p><pre><code class="c">long getMaxLong() {      return ((unsigned long)-1) &gt;&gt; 1;    //2147483647  }</code></pre><p>JAVA版<br>代码代码如下:</p><pre><code class="java">long getMaxLong() {      return ((long)1&lt;&lt;127)-1;    //9223372036854775807  }</code></pre><p>获得long最小值，和其他类型的最大值，最小值同理.   </p><p><strong>四.乘以2运算</strong><br>代码代码如下:</p><pre><code class="c">int mulTwo(int n) {    //计算n*2       return n&lt;&lt;1;  }</code></pre><p><strong>五.除以2运算</strong><br>代码代码如下:  </p><pre><code class="c">int divTwo(int n) {    //负奇数的运算不可用      return n&gt;&gt;1;    //除以2  }</code></pre><p><strong>六.乘以2的m次方</strong><br>代码代码如下:</p><pre><code class="c">int divTwoPower(int n,int m){    //计算n/(2^m)      return n&gt;&gt;m;  }</code></pre><p><strong>七.除以2的m次方</strong><br>代码代码如下:</p><pre><code class="c">int divTwoPower(int n,int m) {    //计算n/(2^m)      return n&gt;&gt;m;  }</code></pre><p><strong>八.判断一个数的奇偶性</strong><br>代码代码如下:</p><pre><code class="c">boolean isOddNumber(int n) {      return (n &amp; 1) == 1;  }</code></pre><p><strong>九.不用临时变量交换两个数</strong><br>C语言版<br>代码代码如下:</p><pre><code class="c">void swap(int *a,int *b) {         (*a)^=(*b)^=(*a)^=(*b);   }</code></pre><p>通用版（一些语言中得分开写）<br>代码代码如下:</p><pre><code class="c">a ^= b;  b ^= a;  a ^= b;</code></pre><p><strong>十.取绝对值</strong><br>代码代码如下:</p><pre><code class="c">int abs(int n){      return (n ^ (n &gt;&gt; 31)) - (n &gt;&gt; 31);   }/* n&gt;&gt;31 取得n的符号，若n为正数，n&gt;&gt;31等于0，若n为负数，n&gt;&gt;31等于-1 若n为正数 n^0=0,数不变，若n为负数有n^-1 需要计算n和-1的补码，然后进行异或运算， 结果n变号并且为n的绝对值减1，再减去-1就是绝对值 */</code></pre><p><strong>十一.取两个数的最大值</strong><br>通用版<br>复制代码代码如下:</p><pre><code class="c">int max(int a,int b) {      return b&amp;((a-b)&gt;&gt;31) | a&amp;(~(a-b)&gt;&gt;31);      // 如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1}</code></pre><p>C语言版<br>代码代码如下:</p><pre><code class="c">int max(int x,int y) {      return x ^ ((x ^ y) &amp; -(x &lt; y));      /*如果x&lt;y x&lt;y返回1，否则返回0， 与0做与运算结果为0，与-1做与运算结果不变*/  }</code></pre><p><strong>十二.取两个数的最小值</strong><br>通用版<br>代码代码如下:</p><pre><code class="c">int min(int a,int b) {      return a&amp;((a-b)&gt;&gt;31) | b&amp;(~(a-b)&gt;&gt;31);      // 如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1 }</code></pre><p>C语言版<br>代码代码如下:</p><pre><code class="c">int min(int x,int y) {      return y ^ ((x ^ y) &amp; -(x &lt; y));          // 如果x&lt;y x&lt;y返回1，否则返回0，         // 与0做与运算结果为0，与-1做与运算结果不变}</code></pre><p><strong>十三.判断符号是否相同</strong><br>代码如下:</p><pre><code class="c">boolean isSameSign(int x, int y) {      return (x ^ y) &gt; 0;     // true 表示 x和y有相同的符号， false表示x，y有相反的符号。  }</code></pre><p><strong>十四.计算2的n次方</strong><br>代码代码如下:</p><pre><code class="c">int getFactorialofTwo(int n) {    //n &gt; 0      return 2&lt;&lt;(n-1);        //2的n次方  }</code></pre><p><strong>十五.判断一个数是不是2的幂</strong><br>代码代码如下:</p><pre><code class="c">boolean isFactorialofTwo(int n) {      return (n &amp; (n - 1)) == 0;      // 如果是2的幂，n一定是100... n-1就是1111....     // 所以做与运算结果为0 }</code></pre><p><strong>十六.对2的n次方取余</strong><br>代码代码如下:</p><pre><code class="c">int quyu(int m,int n) {    //n为2的次方      return m &amp; (n - 1);      // 如果是2的幂，n一定是100... n-1就是1111....     // 所以做与运算结果保留m在n范围的非0的位}</code></pre><p><strong>十七.求两个整数的平均值</strong><br>代码代码如下:</p><pre><code class="c">int getAverage(int x, int y) {          return (x+y) &gt;&gt; 1;   ｝</code></pre><p>另一种写法<br>代码代码如下:</p><pre><code class="c">int getAverage(int x, int y) {          return ((x^y) &gt;&gt; 1) + (x&amp;y);        // (x^y) &gt;&gt; 1得到x，y其中一个为1的位并除以2，      // x&amp;y得到x，y都为1的部分，加一起就是平均数了 }</code></pre><p>下面是三个最基本对二进制位的操作<br><strong>十八.从低位到高位,取n的第m位</strong><br>代码代码如下:</p><pre><code class="c">int getBit(int n, int m) {      return (n &gt;&gt; (m-1)) &amp; 1;  }</code></pre><p><strong>十九.从低位到高位.将n的第m位置1</strong><br>代码代码如下:</p><pre><code class="c">int setBitToOne(int n, int m) {      return n | (1&lt;&lt;(m-1));      // 将1左移m-1位找到第m位，得到000...1...000     // n在和这个数做或运算}</code></pre><p><strong>二十.从低位到高位,将n的第m位置0</strong><br>代码代码如下:</p><pre><code class="c">int setBitToZero(int n, int m) {      return n &amp; ~(1&lt;&lt;(m-1));      // 将1左移m-1位找到第m位，取反后变成111...0...1111     // n再和这个数做与运算 }</code></pre><p>另附一些对程序效率上没有实质提高的位运算技巧，一些也是位运算的常识（面试也许会遇到）<br>计算n+1<br>代码代码如下:</p><pre><code class="c">-~n</code></pre><p>计算n-1<br>代码代码如下:</p><pre><code class="c">~-n</code></pre><p>取相反数<br>代码代码如下:</p><pre><code class="c">~n + 1;</code></pre><p>另一种写法<br>代码代码如下:</p><pre><code class="c">(n ^ -1) + 1;  if(x == a) x = b; if(x == b) x = a;</code></pre><p>代码代码如下:</p><pre><code class="c">x = a ^ b ^ x;</code></pre><p>sign函数，参数为n，当n&gt;0时候返回1，n&lt;0时返回-1，n=0时返回0<br>复制代码代码如下:</p><pre><code class="c">return !!n - (((unsigned)n&gt;&gt;31)&lt;&lt;1);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一.获得int型最大值&lt;/strong&gt;&lt;br&gt;代码代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int getMaxInt() {  
    return (1&amp;lt;&amp;lt;31) - 1;    //2147483647， 由于优先级
      
    
    </summary>
    
      <category term="位运算" scheme="http://yoursite.com/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/12/25/hello-world/"/>
    <id>http://yoursite.com/2017/12/25/hello-world/</id>
    <published>2017-12-25T13:52:00.000Z</published>
    <updated>2017-12-26T09:46:11.731Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="MK" scheme="http://yoursite.com/categories/MK/"/>
    
    
      <category term="MarkDown" scheme="http://yoursite.com/tags/MarkDown/"/>
    
  </entry>
  
</feed>

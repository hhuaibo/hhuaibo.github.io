<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Charles</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.icharles.top/"/>
  <updated>2017-12-28T14:35:23.077Z</updated>
  <id>http://www.icharles.top/</id>
  
  <author>
    <name>Charles</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>信息导论</title>
    <link href="http://www.icharles.top/2017/12/28/%E4%BF%A1%E6%81%AF%E5%AF%BC%E8%AE%BA/"/>
    <id>http://www.icharles.top/2017/12/28/信息导论/</id>
    <published>2017-12-28T14:34:00.000Z</published>
    <updated>2017-12-28T14:35:23.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息技术导论"><a href="#信息技术导论" class="headerlink" title="信息技术导论"></a>信息技术导论</h2><h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><p> 1、<strong>信息</strong>的定义：信息是有秩序的度量，是人们对事物了解的不确定性的消除或减少，是有组织化程度的度量。    </p><p> 2、<strong>数据、消息、信号与信息</strong>的区别：    </p><blockquote><p> ①数据是对客观实体的一种描述形式，是信息的载体。数据是未加工的信息，而信息是数据经过加<br>    工以后能为某个目的使用的数据，信息是数据的内容或者诠释。<br> ②信息是包含在消息中的抽象量，消息是具体的，其中蕴含着信息。<br> ③信号是把消息变换成适合信道传输的物理量。信号携带消息，是消息的运载工具。  </p></blockquote><p> 3、<strong>信息技术四基元</strong>（核心技术）：</p><blockquote><p>   ①感测技术：感觉器官功能的延长。包括传感技术和测量技术。<br>   ②通信技术：传导神经网络功能的延长。包括数字通信、卫星通信、微波通信、光纤通信、光通信技术、无线技术。<br>   ③计算机与智能技术：思维感官功能的延长。包括计算机技术和人工智能技术。包括多媒体技术、信息处理技术。<br>   ④控制技术：效应感官功能的延长。包括线性控制。  </p></blockquote><p> 4、<strong>信息技术的支撑技术</strong>： 电子与微电子技术、机械技术、光电子技术、生物技术。  </p><p> 5、信息技术的<strong>主要支撑技术</strong>：微电子技术，研究核心：集成电路或集成系统的设计制造</p><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><p> 1、<strong>计算科学定义</strong>：是对描述和变换信息的算法过程，包括对其理论，分析，设计，效率，实现和应用等进行的系统研究。     </p><p> 2、<strong>计算机科学研究领域</strong>：计算机系统结构，程序设计科学与方法论，软件工程基础理论，人工智能与知    识处理，网络、数据库及各种计算机辅助技术，论理计算机科学，计算机科学史。    </p><p> 3、<strong>计算机科学的领域</strong>：计算机科学，计算机工程，软件工程，信息系统，信息技术。</p><p> 4、<strong>信息技术学科知识领域</strong>：信息技术基础，人机交互，程序设计基础，信息管理等。   </p><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3><p>1、<strong>冯.诺依曼原理</strong>：</p><blockquote><p>①计算机可以使用二进制；<br>②计算机的指令和数据都可以存储在机内；<br>③计算机系统由储存器、运算器、控制器、输入设备、输出设备组成。  </p></blockquote><p> 2、1946年第一台计算机ENICA研制成功。（电子管计算机）  </p><p> 3、现在计算机发展的<strong>四个阶段</strong>：</p><blockquote><p>①采用<strong>电子管</strong>计算机的第一代计算机（1946-1957）<br>②采用<strong>晶体管</strong> 的第二代电子计算机（1958-1964）<br>③采用<strong>集成电路</strong>的第三代计算机（1965-1970）<br>④使用<strong>超大规模集成电路</strong>的第四代计算机（1970至今）   </p></blockquote><p> 4、<strong>计算机的特点</strong>：</p><blockquote><p>①运算速度快<br>②计算精度高<br>③具有超强记忆和逻辑判断能力<br>④实现自动控制并且具备人机交互功能<br>⑤可靠性高<br>⑥跨地域信息资源共享   </p></blockquote><p>5、电子计算机系统构成：</p><p>6、输入设备打印机：数码打印机，彩色喷墨打印机，彩色激光打印机  </p><p>7、计算机总线定义：用于连接CPU、主存和I/O控制器的总线称为外部设备总线或外部总线。   </p><p>8、常见总线：ISA（工业标准体系接口）,PCI（外部设备互连）,SCSI（小型计算机系统接口）等。</p><p>9、数据传输方式：串行传输接口，并行传输接口。    </p><p>10、计算机性能指标：字长，主频，存储器容量，运算速度，系统可靠性  </p><h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><p>1、</p><blockquote><p><strong>B/S模式</strong>：浏览器/服务器模式<br> <strong>C/S模式</strong>：客户机/服务器模式  </p><p><strong>共同有优点</strong>：用户使用单一浏览器软件就可以访问文本，图像，声音及数据库等信息，由于用户端无需专用的软件，因此当企业对网络应用进行升级时，只需更新服务器端的软件，减轻了系统维护与升级的成本与工作量。     </p><p> <strong>相比优点</strong>（B/S模式）：系统开发，维护，升级方便；具有很强的开发性；结构易于扩展；用户使用方便。</p></blockquote><p> 2、<strong>系统软件</strong>：用于计算机内部的管理，维护，控制运行，以及以及计算机程序的翻译，编辑，控制运行等的软件能使用户方便地操作计算机。   </p><p> 3、</p><blockquote><p><strong>操作系统定义</strong>：是管理软硬件资源，控制程序执行，改善人机界面，合理组织计算机工作流程和为用户计算机提供良好运行环境，并由一系列具有控制和管理功能的子程序组成的大型系统软件。        </p><p><strong>操作系统作用</strong>：管理计算机的全部软硬件资源，提高计算机利用率，担任用户与计算机之间的接口，使用户通过操作系统提供的命令或菜单方便地使用计算机。  </p><p> <strong>操作系统功能</strong>：处理机管理，存储管理，I/O设备管理，文件系统和用户接口，作业管理等。<br><strong>操作系统主要特性</strong>：并发性，共享性，异步性。</p><p><strong>操作系统分类</strong>：单用户操作系统，批处理操作系统，实时操作系统，分时操作系统，网络操作系统，分布式操作系统，微机操作系统。  </p></blockquote><p>4、<strong>应用软件</strong>：是指在操作系统和支持软件的支持下，软件厂商为用户开发的通用软件或专用软件，以及用户开发的应用程序等。<br>  <strong>常用应用软件</strong>：科学和工程计算软件，字表处理软件，图像处理软件，网络应用软件，应用数据库软件。 </p><h3 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h3><p>  1、</p><blockquote><p><strong>媒体定义</strong>：信息的表现形式，承载信息的实际载体，如纸介质，磁盘，光盘；或表达信息的逻辑载体，如文字，图像，语言。<br> <strong>媒体分类</strong>：感觉媒体，表示媒体，显示媒体，存储媒体，传输媒体。 </p></blockquote><p>2、<strong>多媒体定义</strong>：是各种感觉媒体的组合。  </p><blockquote><ul><li>广义：指多种信息媒体的表现形式和传播形式。  </li><li>狭义：指人们用计算机及其他设备交互处理多种媒体信息的手段，或指在计算机中处理多种媒体的一系列技术。          </li><li>特性：信息载体的多样化，集成性，多媒体的交互性，数字化，实时性。</li></ul></blockquote><p> 3、<strong>多媒体技术定义</strong>：是指通过计算机对文字、数据、图形、图像、动画、声音等多种媒体<br>信息进行综合处理和管理，使用户可以通过多种感官与计算机进行实时信息交互的技术 。    </p><p><strong>特性</strong>：  </p><blockquote><p>1、能够完成在内容上相关联的多媒体信息的处理和传送<br> 2、交互式工作，而不是简单的单向或双向传输<br> 3、网络联结，即各种媒体信息是通过网络传输的 </p></blockquote><h3 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h3><p> 1、</p><blockquote><p><strong>算法定义</strong>：是对问题求解过程的一种描述，是为解决一个或一类问题给出的一个确定的有限长的操作序列。<br><strong>特性</strong>：有穷性，确定性，可行性，有输出，有输入。   </p></blockquote><p> 2、</p><blockquote><p><strong>程序定义</strong>：是为实现特定目标或解决特定问题而用计算机语言编写的命令序列的集合，为实现预期的目的而进行操作的一系列语言和指令。<br><strong>基本要素</strong>：常量，变量，表达式，语句，函数。 </p></blockquote><p>3、<strong>程序设计的一般过程</strong>：分析问题，建立数学模型，确定算法，编写程序，调试运行，分析结果，写出程序的文档。  </p><p>4、程序设计语言提供了哪几种结构：<strong>选择结构，顺序结构，循环结构</strong>。 </p><p> 5、<strong>数据结构定义</strong>：相互之间存在着一定关系的数据元素的集合及定义在其上的操作。 </p><p>6、<strong>常见的数据结构类型</strong>：</p><blockquote><p>线性结构、树状结构、图形结构、集合结构。  </p><p>线性结构：<br>一、栈：只能在某一端插入和删除的特殊线性表。<br> 二、队列：限定在一端进行插入，另一端进行删除的特殊线性表。<br>三、链表：指用一组任意的储存单元来依次存放线性表的数据元素。 </p><p>树状结构：一般树，二叉树。  </p></blockquote><h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h3><p> 1、<strong>数据定义</strong>：是指所有能输入到计算机并被计算机程序处理的符号的介质的总称，是用于输入电子计算机进行处理，具有一定意义的数字，字母，符号和模拟量通称。    </p><blockquote><p><strong>数据库</strong>：以一定结构存储在一起且相互关联的，结构化数据集合。 </p><p>   <strong>关系数据库</strong>：是建立在关系数据库模型基础上的数据库，借助于集合代数等概念和方法来处理数据库中的数据，同时也是一个被组织成一组拥有正式描述性的表格。  </p></blockquote><p>2、<strong>数据库系统的概念</strong>：以计算机为基础的记录保持系统，其目的是要记录和保持信息。            主要包括：数据库，数据库管理系统，数据库应用系统，数据库用户。</p><p>3、<strong>数据库管理系统的定义</strong>：是用于描述，管理和维护数据库的软件系统，是数据库系统的核心组成部分。                   功能：描述数据库，管理数据库，维护数据库。    </p><p> 4、<strong>数据库系统的特点</strong>：</p><blockquote><p>一、可实现数据共享<br>二、可减少数据冗余<br>三、在一定程度上可避免不相容<br>四、可实施标准化<br>五、可保证数据安全<br>六、可保证完整性   </p></blockquote><p>5、<strong>概念模型</strong> 和 <strong>数据模型</strong> 的 <strong>区别</strong>：  </p><blockquote><p><strong>概念模型</strong>是在信息世界中形成的，按用户的观点对数据进行建模，主要用于表示数据的逻辑特征，如实体，属性和联系。<br>  <strong>数据模型</strong>是数据库系统中用于提供信息表示和操作手段的形式构架，是对现实数据特征的抽象。数据模型包含概念模型，其三要素是数据结构，数据操作，完整性约束。  </p></blockquote><p>6、关系模型支持的三种基本运算：选择，投影，连接。</p><p> 7、数据模型分为：概念模型，实施模型。    </p><p> 8、关系数据库（SQL）特点：</p><blockquote><p>一、数据高度结构化。<br> 二、易于编制应用程序。<br>三、数据独立性高。<br>四、功能强大。<br>五、理论基础深。  </p></blockquote><h3 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h3><p>1、<strong>计算机网络定义</strong>：是将地理位置不同的具有独立功能的计算机或由计算机控制的外部设备，通过通信设备和传输介质连接起来，在网络操作系统的控制下，按照约定的通信协议进行信息交换，实现资源共享的系统。 </p><p><strong>功能</strong>：</p><blockquote><p>一、数据通信和交换，传真，电子邮件电子数据交换，电子公告，远程登录和信息浏览<br>二、资源共享<br>三、提高计算机的可靠性和可用性<br>四、 分布式网络处理<br>五、均衡负荷，相互协作<br>六、提高系统性能价格比，易于扩充，便于维护</p></blockquote><p> 2、<strong>计算机网络类型</strong>：广域网（WNA），局域网（LNA），城域网（MNA）。 </p><p>3、按<strong>扑拓结构划</strong>分网络类型：星状网，总线网，环状网，树状网，网状网。  </p><p>4、<strong>OSI参考模型</strong>：开放系统互连参考模型，定义了连接异种计算机标准的主体结构，是设计和描述网络通信的基本框架。（侧重功能层次）         </p><blockquote><p><strong>主要功能</strong>（七层）：网络低层：物理层，数据链路层，网络层<br><strong>网络高层</strong>：运输层，会话层，表示层，应用层。</p></blockquote><p> 5、<strong>TCP/IP协议</strong>（侧重数据传输 ：应用层，传输层，网际层，网络接口层。 </p><p> 6、<strong>Internet提供的服务</strong>：电子邮件，文件传输，万维网，电视广播，远程登录服务，网络新闻，电子杂志，新闻群组，索引服务。  </p><p>7、<strong>IP</strong>：网际层，网际协议，能够寻址，建立一个全球的寻址空间。</p><p>  8、<strong>TCP</strong>：传输层，传输控制协议，为进程与进程之间提供了一种可靠的顺序通信链路或者是虚拟电路，目的是交换了全双工的数据流。</p><p>  9、<strong>Internet常见设备</strong>：中继器，网桥，路由器，网关。   </p><h3 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h3><p>  1、<strong>信息系统定义</strong>：是指基于计算机通信网络等现代化的工具和手段，服务于管理领域的信息处理系统。<br> <strong>功能</strong>：信息采集，信息处理，信息存储保管，大体包括信息采集，加工，存储，传输，检索等处理。 </p><p> 2、<strong>信息系统开发过程</strong>：系统规划，系统分析，系统设计，系统实施，系统的运行和维护</p><p> 3、<strong>信息系统开发的方法</strong>：生命周期法，原型法，面向对象法，螺旋法，瀑布法，结构化开发方法。    </p><h3 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h3><p>  1、<strong>信息资源特征</strong>：</p><blockquote><p>一、共享性与选择性<br>二、稀缺性与时效性<br>三、积累性与保存性<br>四、无限性与有限性并存<br>五、增值性<br>六、剧增性与多样性   </p></blockquote><p>2、<strong>信息检索定义</strong>：根据特定用户在特定时间和条件下的需求，运用某种工具，按照一定的过程，方法和技术，从各种各样的信息资源中找出所需的信息，以形成用户所需要的信息资源的过程。  </p><p>3、<strong>搜索引擎定义</strong>：是专门提供信息查询服务的网站安装在其服务器上的一种能在网上漫游并搜索它所得到的信息，同时自动生成本地索引的软件，是因特网上最为有效的信息导航工具。   </p><h3 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h3><p>1、<strong>信息安全概念</strong>（计算机信息系统安全保护）：保护计算机及其相关配套设施安全，运行环境安全，信息安全，计算机功能正常发挥，以维护计算机信息系统的安全运行。  </p><p> 2、信息保障四个方面：<strong>保护，检测，反应，恢复</strong>。 </p><p> 3、</p><blockquote><p><strong>病毒</strong>概念：是能够通过某种途径潜伏在存储介质里，当达到某种条件是即被激活的具有对计算机资源进行破坏作用的一组程序或指令集合。<br>  <strong>传播途径</strong>：存储介质，网络传输，运行程序。（磁盘，光盘，网络）<br> <strong>特征</strong>：传染性，非授权性，隐蔽性，潜伏性，破坏性。    </p></blockquote><p>4、<strong>防火墙技术</strong>：将内部网和公众访问网分开的方法，在两个网络通信是执行的一种访问控制尺度，是一种隔离技术，在某个机构的网络和不安全的网络之间设置屏障，阻止对信息资源的非法访问，或者阻止重要信息从企业网络上非法输出。  </p><p><strong>基本准则</strong>：</p><blockquote><p>一、一切未被允许的就是禁止的<br>二、一切未被禁止的就是允许的 </p><p><strong>种类</strong>：滤防火墙，应用级网关，状态监视器。<br> <strong>基本功能</strong>：网络安全的保障：；强化网络安全策略；有效地记录网络上的活动；防止内部网受到侵害。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;信息技术导论&quot;&gt;&lt;a href=&quot;#信息技术导论&quot; class=&quot;headerlink&quot; title=&quot;信息技术导论&quot;&gt;&lt;/a&gt;信息技术导论&lt;/h2&gt;&lt;h3 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章
      
    
    </summary>
    
      <category term="Examination" scheme="http://www.icharles.top/categories/Examination/"/>
    
    
      <category term="Examination" scheme="http://www.icharles.top/tags/Examination/"/>
    
  </entry>
  
  <entry>
    <title>欧几里得算法</title>
    <link href="http://www.icharles.top/2017/12/27/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    <id>http://www.icharles.top/2017/12/27/欧几里得算法/</id>
    <published>2017-12-27T08:29:00.000Z</published>
    <updated>2017-12-27T13:20:40.664Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我的个人博客：地址"><a href="#我的个人博客：地址" class="headerlink" title="我的个人博客：地址"></a>我的个人博客：<a href="http://www.icharles.top/2017/12/15/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/">地址</a></h3><p><strong>欧几里得算法</strong>计算的是两个自然数a和b的最大公约数，两个数的最大公约数通常写成gcd(a, b)，如果有gcd(a, b)==1，则有a，b互质。</p><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><ul><li><p>递归</p><pre><code class="c">int Gcd(int a, int b){  if(b == 0)      return a;  return Gcd(b, a % b);}</code></pre></li><li><p>迭代</p><pre><code class="c">int Gcd(int a, int b){  while(b != 0)  {      int r = b;      b = a % b;      a = r;  }  return a;}</code></pre></li></ul><h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><ul><li><p>介绍<br><strong>扩展欧几里德算法</strong>是用来在已知a, b求解一组p，q使得p<em>a+q</em>b=Gcd(a,b)(根据数论中的相关定理解一定存在，不展开叙述)。扩展欧几里德常用在求解模线性方程及方程组中。</p></li><li><p>算法</p><pre><code class="C">int exGcd(int a, int b, int &amp;x, int &amp;y){  if(b == 0)  {      x = 1;      y = 0;      return a;  }  int r = exGcd(b, a % b, x, y);  int t = x;  x = y;  y = t - a / b * y;  return r;}</code></pre></li><li>理解<br>把这个实现和Gcd的递归实现相比，发现多了下面的x,y赋值过程，这就是扩展欧几里德算法的精髓。 可以这样思考: 对于a’ =b , b’ =a%b 而言，我们求得x, y使得a’ x+b’ y=Gcd(a’, b’) 由于b’ = a % b = a - a / b <em> b 那么可以得到 :<br>a’ x + b’ y = Gcd(a’ , b’)<br>===&gt;<br>bx + (a - a/b </em>b)y = Gcd(a’ , b’) = Gcd(a, b)  //注意到这里的/是C语言中的出发<br>===&gt;<br>ay + b(x- a/b <em>y) = Gcd(a, b)<br>因此对于a和b而言，他们的相对应的p，q分别是 y和(x-a/b</em>y)</li></ul><p><a href="https://my.oschina.net/u/1780798/blog/646739" target="_blank" rel="noopener">推荐文章 ：https://my.oschina.net/u/1780798/blog/646739</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;我的个人博客：地址&quot;&gt;&lt;a href=&quot;#我的个人博客：地址&quot; class=&quot;headerlink&quot; title=&quot;我的个人博客：地址&quot;&gt;&lt;/a&gt;我的个人博客：&lt;a href=&quot;http://www.icharles.top/2017/12/15/%E6%AC%A
      
    
    </summary>
    
      <category term="算法" scheme="http://www.icharles.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.icharles.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Vector--STL</title>
    <link href="http://www.icharles.top/2017/12/27/Vector-STL/"/>
    <id>http://www.icharles.top/2017/12/27/Vector-STL/</id>
    <published>2017-12-27T08:27:00.000Z</published>
    <updated>2017-12-27T13:20:28.739Z</updated>
    
    <content type="html"><![CDATA[<p>我的个人博客：  <a href="http://www.icharles.top/2017/12/15/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91STL-Vector/">地址</a></p><p><strong>vector(向量)</strong><br>vector类称作向量类，它实现了动态数组，用于元素数量变化的对象数组。像数组一样，vector类也用从0开始的下标表示元素的位置；但和数组不同的是，当vector对象创建后，数组的元素个数会随着vector对象元素个数的增大和缩小而自动变化。<br>用法:</p><pre><code class="c">#include&lt;vector&gt;using namespace std;vector &lt;int &gt; aint b = 5;a.push_back(b); //该函数下面有详解cout&lt;&lt;a[0];        //输出结果为5</code></pre><table><thead><tr><th>函数</th><th>动作</th></tr></thead><tbody><tr><td>push_back</td><td>在数组的最后添加一个数据</td></tr><tr><td>pop_back</td><td>去掉数组的最后一个数据</td></tr><tr><td>at</td><td>得到编号位置的数据</td></tr><tr><td>begin</td><td>得到数组头的指针</td></tr><tr><td>end</td><td>得到数组的最后一个单元+1的指针</td></tr><tr><td>front</td><td>得到数组头的引用</td></tr><tr><td>back</td><td>得到数组的最后一个单元的引用</td></tr><tr><td>max_size</td><td>得到vector最大可以是多大</td></tr><tr><td>capacity</td><td>当前vector分配的大小</td></tr><tr><td>size</td><td>当前使用数据的大小</td></tr><tr><td>resize</td><td>改变当前使用数据的大小，如果它比当前使用的大，者填充默认值</td></tr><tr><td>reserve</td><td>改变当前vecotr所分配空间的大小</td></tr><tr><td>erase</td><td>删除指针指向的数据项</td></tr><tr><td>clear</td><td>清空当前的vector</td></tr><tr><td>rbegin</td><td>将vector反转后的开始指针返回(其实就是原来的end-1)</td></tr><tr><td>rend</td><td>将vector反转构的结束指针返回(其实就是原来的begin-1)</td></tr><tr><td>empty</td><td>判断vector是否为空</td></tr><tr><td>swap</td><td>与另一个vector交换数据</td></tr></tbody></table><p>详细的函数实现功能 ：<br>其中  vector &lt;int&gt; c  </p><table><thead><tr><th>函数</th><th>动作</th></tr></thead><tbody><tr><td>c.clear()</td><td>移除容器中所有元素。</td></tr><tr><td>c.empty()</td><td>判断容器是否为空。</td></tr><tr><td>c.erase(pos)</td><td>删除pos位置之后的一个元素</td></tr><tr><td>c.erase(begin,end)</td><td>删除[begin,end)区间的元素</td></tr><tr><td>c.front()</td><td>传回第一个元素</td></tr><tr><td>c.insert(pos,elem)</td><td>在pos位置之后插入一个elem拷贝</td></tr><tr><td>c.pop_back()</td><td>删除最后一个元素</td></tr><tr><td>c.push_back(elem)</td><td>在尾部加入一个元素</td></tr><tr><td>c.resize(num)</td><td>重新设置该容器的大小</td></tr><tr><td>c.size()</td><td>回容器中元素的个数</td></tr><tr><td>c.begin()</td><td>返回指向容器第一个元素的迭代器</td></tr><tr><td>c.end()</td><td>返回指向容器最后一个元素的迭代器</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我的个人博客：  &lt;a href=&quot;http://www.icharles.top/2017/12/15/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91STL-Vector/&quot;&gt;地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;vector(向量)&lt;/s
      
    
    </summary>
    
      <category term="STL" scheme="http://www.icharles.top/categories/STL/"/>
    
    
      <category term="STL" scheme="http://www.icharles.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>位运算技巧</title>
    <link href="http://www.icharles.top/2017/12/26/%E4%BD%8D%E8%BF%90%E7%AE%97%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.icharles.top/2017/12/26/位运算技巧/</id>
    <published>2017-12-26T10:03:00.000Z</published>
    <updated>2017-12-27T13:24:18.970Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一.获得int型最大值</strong><br>代码代码如下:</p><pre><code class="c">int getMaxInt() {      return (1&lt;&lt;31) - 1;    //2147483647， 由于优先级关系，括号不可省略}</code></pre><p>另一种写法<br>代码代码如下:</p><pre><code class="c">int getMaxInt() {      return -(1&lt;&lt;-1) - 1;    //2147483647  }</code></pre><p>另一种写法<br>代码代码如下:</p><pre><code class="c">int getMaxInt() {      return ~(1&lt;&lt;31);//2147483647  }</code></pre><p>C语言中不知道int占几个字节时候<br>代码代码如下:</p><pre><code class="c">int getMaxInt(){      return ((unsigned int)-1) &gt;&gt; 1;//2147483647  }</code></pre><p><strong>二.获得int型最小值</strong><br>复制代码代码如下:</p><pre><code class="c">int getMinInt() {      return 1&lt;&lt;31;    //-2147483648   }</code></pre><p>另一种写法<br>代码代码如下:</p><pre><code class="c">int getMinInt(){      return 1 &lt;&lt; -1;//-2147483648  }</code></pre><p><strong>三.获得long类型的最大值</strong><br>C语言版<br>代码代码如下:</p><pre><code class="c">long getMaxLong() {      return ((unsigned long)-1) &gt;&gt; 1;    //2147483647  }</code></pre><p>JAVA版<br>代码代码如下:</p><pre><code class="java">long getMaxLong() {      return ((long)1&lt;&lt;127)-1;    //9223372036854775807  }</code></pre><p>获得long最小值，和其他类型的最大值，最小值同理.   </p><p><strong>四.乘以2运算</strong><br>代码代码如下:</p><pre><code class="c">int mulTwo(int n) {    //计算n*2       return n&lt;&lt;1;  }</code></pre><p><strong>五.除以2运算</strong><br>代码代码如下:  </p><pre><code class="c">int divTwo(int n) {    //负奇数的运算不可用      return n&gt;&gt;1;    //除以2  }</code></pre><p><strong>六.乘以2的m次方</strong><br>代码代码如下:</p><pre><code class="c">int divTwoPower(int n,int m){    //计算n/(2^m)      return n&gt;&gt;m;  }</code></pre><p><strong>七.除以2的m次方</strong><br>代码代码如下:</p><pre><code class="c">int divTwoPower(int n,int m) {    //计算n/(2^m)      return n&gt;&gt;m;  }</code></pre><p><strong>八.判断一个数的奇偶性</strong><br>代码代码如下:</p><pre><code class="c">boolean isOddNumber(int n) {      return (n &amp; 1) == 1;  }</code></pre><p><strong>九.不用临时变量交换两个数</strong><br>C语言版<br>代码代码如下:</p><pre><code class="c">void swap(int *a,int *b) {         (*a)^=(*b)^=(*a)^=(*b);   }</code></pre><p>通用版（一些语言中得分开写）<br>代码代码如下:</p><pre><code class="c">a ^= b;  b ^= a;  a ^= b;</code></pre><p><strong>十.取绝对值</strong><br>代码代码如下:</p><pre><code class="c">int abs(int n){      return (n ^ (n &gt;&gt; 31)) - (n &gt;&gt; 31);   }/* n&gt;&gt;31 取得n的符号，若n为正数，n&gt;&gt;31等于0，若n为负数，n&gt;&gt;31等于-1 若n为正数 n^0=0,数不变，若n为负数有n^-1 需要计算n和-1的补码，然后进行异或运算， 结果n变号并且为n的绝对值减1，再减去-1就是绝对值 */</code></pre><p><strong>十一.取两个数的最大值</strong><br>通用版<br>复制代码代码如下:</p><pre><code class="c">int max(int a,int b) {      return b&amp;((a-b)&gt;&gt;31) | a&amp;(~(a-b)&gt;&gt;31);      // 如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1}</code></pre><p>C语言版<br>代码代码如下:</p><pre><code class="c">int max(int x,int y) {      return x ^ ((x ^ y) &amp; -(x &lt; y));      /*如果x&lt;y x&lt;y返回1，否则返回0， 与0做与运算结果为0，与-1做与运算结果不变*/  }</code></pre><p><strong>十二.取两个数的最小值</strong><br>通用版<br>代码代码如下:</p><pre><code class="c">int min(int a,int b) {      return a&amp;((a-b)&gt;&gt;31) | b&amp;(~(a-b)&gt;&gt;31);      // 如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1 }</code></pre><p>C语言版<br>代码代码如下:</p><pre><code class="c">int min(int x,int y) {      return y ^ ((x ^ y) &amp; -(x &lt; y));          // 如果x&lt;y x&lt;y返回1，否则返回0，         // 与0做与运算结果为0，与-1做与运算结果不变}</code></pre><p><strong>十三.判断符号是否相同</strong><br>代码如下:</p><pre><code class="c">boolean isSameSign(int x, int y) {      return (x ^ y) &gt; 0;     // true 表示 x和y有相同的符号， false表示x，y有相反的符号。  }</code></pre><p><strong>十四.计算2的n次方</strong><br>代码代码如下:</p><pre><code class="c">int getFactorialofTwo(int n) {    //n &gt; 0      return 2&lt;&lt;(n-1);        //2的n次方  }</code></pre><p><strong>十五.判断一个数是不是2的幂</strong><br>代码代码如下:</p><pre><code class="c">boolean isFactorialofTwo(int n) {      return (n &amp; (n - 1)) == 0;      // 如果是2的幂，n一定是100... n-1就是1111....     // 所以做与运算结果为0 }</code></pre><p><strong>十六.对2的n次方取余</strong><br>代码代码如下:</p><pre><code class="c">int quyu(int m,int n) {    //n为2的次方      return m &amp; (n - 1);      // 如果是2的幂，n一定是100... n-1就是1111....     // 所以做与运算结果保留m在n范围的非0的位}</code></pre><p><strong>十七.求两个整数的平均值</strong><br>代码代码如下:</p><pre><code class="c">int getAverage(int x, int y) {          return (x+y) &gt;&gt; 1;   ｝</code></pre><p>另一种写法<br>代码代码如下:</p><pre><code class="c">int getAverage(int x, int y) {          return ((x^y) &gt;&gt; 1) + (x&amp;y);        // (x^y) &gt;&gt; 1得到x，y其中一个为1的位并除以2，      // x&amp;y得到x，y都为1的部分，加一起就是平均数了 }</code></pre><p>下面是三个最基本对二进制位的操作<br><strong>十八.从低位到高位,取n的第m位</strong><br>代码代码如下:</p><pre><code class="c">int getBit(int n, int m) {      return (n &gt;&gt; (m-1)) &amp; 1;  }</code></pre><p><strong>十九.从低位到高位.将n的第m位置1</strong><br>代码代码如下:</p><pre><code class="c">int setBitToOne(int n, int m) {      return n | (1&lt;&lt;(m-1));      // 将1左移m-1位找到第m位，得到000...1...000     // n在和这个数做或运算}</code></pre><p><strong>二十.从低位到高位,将n的第m位置0</strong><br>代码代码如下:</p><pre><code class="c">int setBitToZero(int n, int m) {      return n &amp; ~(1&lt;&lt;(m-1));      // 将1左移m-1位找到第m位，取反后变成111...0...1111     // n再和这个数做与运算 }</code></pre><p>另附一些对程序效率上没有实质提高的位运算技巧，一些也是位运算的常识（面试也许会遇到）<br>计算n+1<br>代码代码如下:</p><pre><code class="c">-~n</code></pre><p>计算n-1<br>代码代码如下:</p><pre><code class="c">~-n</code></pre><p>取相反数<br>代码代码如下:</p><pre><code class="c">~n + 1;</code></pre><p>另一种写法<br>代码代码如下:</p><pre><code class="c">(n ^ -1) + 1;  if(x == a) x = b; if(x == b) x = a;</code></pre><p>代码代码如下:</p><pre><code class="c">x = a ^ b ^ x;</code></pre><p>sign函数，参数为n，当n&gt;0时候返回1，n&lt;0时返回-1，n=0时返回0<br>复制代码代码如下:</p><pre><code class="c">return !!n - (((unsigned)n&gt;&gt;31)&lt;&lt;1);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一.获得int型最大值&lt;/strong&gt;&lt;br&gt;代码代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;int getMaxInt() {  
    return (1&amp;lt;&amp;lt;31) - 1;    //2147483647， 由于优先级
      
    
    </summary>
    
      <category term="位运算" scheme="http://www.icharles.top/categories/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
      <category term="ACM" scheme="http://www.icharles.top/tags/ACM/"/>
    
  </entry>
  
</feed>

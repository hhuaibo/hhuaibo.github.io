{"meta":{"title":"Charles博客","subtitle":"查尔斯的博客","description":"Charles的个人博客，用此来发表个人见解与笔记","author":"Charles","url":"http://www.icharles.top"},"pages":[{"title":"关于我","date":"2017-12-28T10:32:05.000Z","updated":"2017-12-29T04:00:43.959Z","comments":false,"path":"about/index.html","permalink":"http://www.icharles.top/about/index.html","excerpt":"","text":"CharlesEmail: huaibovip@gmail.comgithub: hhuaibo.github.io"},{"title":"gallery","date":"2018-02-12T09:03:45.000Z","updated":"2017-12-26T09:01:39.233Z","comments":true,"path":"gallery/index.html","permalink":"http://www.icharles.top/gallery/index.html","excerpt":"","text":""},{"title":"links","date":"2017-12-26T09:28:39.000Z","updated":"2017-12-26T09:30:54.308Z","comments":true,"path":"links/index.html","permalink":"http://www.icharles.top/links/index.html","excerpt":"","text":""},{"title":"","date":"2018-02-12T09:03:45.000Z","updated":"2018-01-20T04:17:51.067Z","comments":true,"path":"tags/index.html","permalink":"http://www.icharles.top/tags/index.html","excerpt":"","text":"—title: tagdate: layout: tag"},{"title":"timeline","date":"2018-02-12T09:03:45.000Z","updated":"2017-12-26T09:45:38.456Z","comments":true,"path":"timeline/index.html","permalink":"http://www.icharles.top/timeline/index.html","excerpt":"","text":""}],"posts":[{"title":"Top","slug":"Top","date":"2018-04-13T12:35:42.000Z","updated":"2018-04-13T12:36:21.907Z","comments":false,"path":"2018/04/13/Top/","link":"","permalink":"http://www.icharles.top/2018/04/13/Top/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hexapod","slug":"Hexapod","date":"2018-04-13T12:18:02.000Z","updated":"2018-04-13T12:33:03.173Z","comments":true,"path":"2018/04/13/Hexapod/","link":"","permalink":"http://www.icharles.top/2018/04/13/Hexapod/","excerpt":"Hexapod - 六足机器人制作过程","text":"Hexapod - 六足机器人制作过程 先扯一扯 o(∩_∩)o这是我制作的第一个机器人，暂时还没起名字。第一次接触机器人缘起一张二维码(╯▽╰)╭ ，由此引发后续一系列的故事，之后便加入了由图书馆创客空间成立的机器人工作室。没成想居然是刚刚成立(心想：呵呵)，经历一段时间的学习与感悟....啥也没学会o(╯□╰)o ， 3D打印躯干组装运动及Code title: TOPdate: 2018-01-28 23:23:35banner: http://blog.zhangruipeng.me/hexo-theme-icarus/gallery/salt-lake.jpgthumbnail: http://blog.zhangruipeng.me/hexo-theme-icarus/gallery/salt-lake.jpgcomments: falsedonate: false tags:","categories":[{"name":"Hexapod","slug":"Hexapod","permalink":"http://www.icharles.top/categories/Hexapod/"}],"tags":[{"name":"Robot","slug":"Robot","permalink":"http://www.icharles.top/tags/Robot/"}]},{"title":"Dijkstra","slug":"Dijkstra","date":"2018-01-28T14:23:11.000Z","updated":"2018-02-01T07:51:29.594Z","comments":true,"path":"2018/01/28/Dijkstra/","link":"","permalink":"http://www.icharles.top/2018/01/28/Dijkstra/","excerpt":"单源最短路径（1）：Dijkstra 算法一：背景展开目录Dijkstra 算法（中文名：迪杰斯特拉算法）是由荷兰计算机科学家 Edsger Wybe Dijkstra 提出。该算法常用于路由算法或者作为其他图算法的一个子模块。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该算法可以用来找到两个城市之间的最短路径。","text":"单源最短路径（1）：Dijkstra 算法一：背景展开目录Dijkstra 算法（中文名：迪杰斯特拉算法）是由荷兰计算机科学家 Edsger Wybe Dijkstra 提出。该算法常用于路由算法或者作为其他图算法的一个子模块。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该算法可以用来找到两个城市之间的最短路径。 二：算法过程展开目录我们用一个例子来具体说明迪杰斯特拉算法的流程。定义源点为 0， dist[i] 为源点 0 到顶点 i 的最短路径。其过程描述如下： 步骤 dist[1] dist[2] dist[3] dist[4] 已找到的集合 第 1 步 8 1 2 +∞ {2} 第 2 步 8 × 2 4 {2, 3} 第 3 步 5 × × 4 {2, 3, 4} 第 4 步 5 × × × {2, 3, 4, 1} 第 5 步 × × × × {2, 3, 4, 1} 第 1 步：从源点 0 开始，找到与其邻接的点：1，2，3，更新 dist[] 数组，因 0 不与 4 邻接，故 dist[4] 为正无穷。在 dist[] 中找到最小值，其顶点为 2，即此时已找到 0 到 2 的最短路。 第 2 步：从 2 开始，继续更新dist[]数组：2 与 1 不邻接，不更新；2 与 3 邻接，因0→2→3比dist[3]大，故不更新dist[3] ；2 与 4 邻接，因0→2→4比dist[4]小，故更新dist[4]为 4。在dist[]中找到最小值，其顶点为 3，即此时又找到 0 到 3 的最短路。 第 3 步：从 3 开始，继续更新 dist[] 数组：3 与 1 邻接，因0→3→1比 dist[1] 小，更新 dist[1] 为 5；3 与 4 邻接，因0→3→4比 dist[4] 大，故不更新。在 dist[] 中找到最小值，其顶点为 4，即此时又找到 0 到 4 的最短路。 第 4 步：从 4 开始，继续更新 dist[] 数组：4 与 1 不邻接，不更新。在 dist[] 中找到最小值，其顶点为 1，即此时又找到 0 到 1 的最短路。 第 5 步：所有点都已找到，停止。 对于上述步骤，你可能存在以下的疑问： 若 A 作为源点，与其邻接的只有 B，C，D 三点，其dist[]最小时顶点为 C，即就可以确定A→C为 A 到 C 的最短路。但是我们存在疑问的是：是否还存在另一条路径使 A 到 C 的距离更小？ 用反证法证明。 假设存在如上图的红色虚线路径，使 A→D→C 的距离更小，那么 A→D 作为 A→D→C 的子路径，其距离也比 A→C 小，这与前面所述 “ dist[] 最小时顶点为 C” 矛盾，故假设不成立。因此这个疑问不存在。 根据上面的证明，我们可以推断出，Dijkstra 每次循环都可以确定一个顶点的最短路径，故程序需要循环 n-1 次。 三：完整代码#include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; int matrix[100][100]; // 邻接矩阵 bool visited[100]; // 标记数组 int dist[100]; // 源点到顶点i的最短距离 int path[100]; // 记录最短路的路径 int source; // 源点 int vertex_num; // 顶点数 int edge_num; // 边数 void Dijkstra(int source) { memset(visited, 0, sizeof(visited)); // 初始化标记数组 visited[source] = true; for (int i = 0; i &lt; vertex_num; i++) { dist[i] = matrix[source][i]; path[i] = source; } int min_cost; // 权值最小 int min_cost_index; // 权值最小的下标 for (int i = 1; i &lt; vertex_num; i++) // 找到源点到另外 vertex_num-1 个点的最短路径 { min_cost = INT_MAX; for (int j = 0; j &lt; vertex_num; j++) { if (visited[j] == false &amp;&amp; dist[j] &lt; min_cost) // 找到权值最小 { min_cost = dist[j]; min_cost_index = j; } } visited[min_cost_index] = true; // 该点已找到，进行标记 for (int j = 0; j &lt; vertex_num; j++) // 更新 dist 数组 { if (visited[j] == false &amp;&amp; matrix[min_cost_index][j] != INT_MAX &amp;&amp; // 确保两点之间有边 matrix[min_cost_index][j] + min_cost &lt; dist[j]) { dist[j] = matrix[min_cost_index][j] + min_cost; path[j] = min_cost_index; } } } } int main() { cout &lt;&lt; &quot;请输入图的顶点数（&lt;100）：&quot;; cin &gt;&gt; vertex_num; cout &lt;&lt; &quot;请输入图的边数：&quot;; cin &gt;&gt; edge_num; for (int i = 0; i &lt; vertex_num; i++) for (int j = 0; j &lt; vertex_num; j++) matrix[i][j] = (i != j) ? INT_MAX : 0; // 初始化 matrix 数组 cout &lt;&lt; &quot;请输入边的信息：\\n&quot;; int u, v, w; for (int i = 0; i &lt; edge_num; i++) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; matrix[u][v] = matrix[v][u] = w; } cout &lt;&lt; &quot;请输入源点（&lt;&quot; &lt;&lt; vertex_num &lt;&lt; &quot;）：&quot;; cin &gt;&gt; source; Dijkstra(source); for (int i = 0; i &lt; vertex_num; i++) { if (i != source) { cout &lt;&lt; source &lt;&lt; &quot;到&quot; &lt;&lt; i &lt;&lt; &quot;最短距离是：&quot; &lt;&lt; dist[i] &lt;&lt; &quot;，路径是：&quot; &lt;&lt; i; int t = path[i]; while (t != source) { cout &lt;&lt; &quot;--&quot; &lt;&lt; t; t = path[t]; } cout &lt;&lt; &quot;--&quot; &lt;&lt; source &lt;&lt; endl; } } return 0; } 输入数据，结果为： 本文来源于： https://www.61mon.com/index.php/archives/194/作者：刘毅","categories":[],"tags":[]},{"title":"KMP","slug":"KMP","date":"2018-01-19T13:31:00.000Z","updated":"2018-01-28T14:55:47.965Z","comments":true,"path":"2018/01/19/KMP/","link":"","permalink":"http://www.icharles.top/2018/01/19/KMP/","excerpt":"利用Next数组来求连续字符串的个数题目地址：Power Strings","text":"利用Next数组来求连续字符串的个数题目地址：Power Strings 题目大体意思就是求连续字符串个数由于刚学习完KMP，就想到了利用Next数组来求连续字符串的个数，发现存在以下关系： N = len / (len - next[len]) #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; using namespace std; const int maxn = 1E6 + 5; char str[maxn]; int nex[maxn], len; void getnext() { int i = 0, j = -1; memset(nex, 0, sizeof(nex)); nex[0] = -1; while(i &lt; len) { if(j == -1 || str[i] == str[j]) { nex[++i] = ++j; } else { j = nex[j]; } } } int main() { while(scanf(&quot;%s&quot;, str) != EOF) { if(str[0] ==&#39;.&#39;) break; len = strlen(str); getnext(); //例如 aaaaa len = 4, len - nex[len] = 1 if(len % (len - nex[len]) == 0) cout &lt;&lt; len / (len - nex[len]) &lt;&lt; endl; else cout &lt;&lt; &quot;1&quot; &lt;&lt; endl; } return 0; }","categories":[{"name":"算法","slug":"算法","permalink":"http://www.icharles.top/categories/算法/"}],"tags":[{"name":"KMP","slug":"KMP","permalink":"http://www.icharles.top/tags/KMP/"}]},{"title":"谷歌访问助手","slug":"谷歌访问助手","date":"2018-01-04T04:21:32.000Z","updated":"2018-01-28T15:04:00.614Z","comments":true,"path":"2018/01/04/谷歌访问助手/","link":"","permalink":"http://www.icharles.top/2018/01/04/谷歌访问助手/","excerpt":"谷歌访问助手安装教程","text":"谷歌访问助手安装教程 本教程以Google Chrome为例，其他浏览器请自行安装，激活方法一样 打开Google Chrome浏览器，如下图 将下载的谷歌访问助手拖到扩展程序 永久激活谷歌访问助手，按照提示进行即可 当然你不会或者嫌麻烦设置主页，可以按照下图步骤点击设置勾选自动打开主页 至此，你就完成所有设置，接下来就是畅游墙外世界别忘记点赞呦","categories":[],"tags":[]},{"title":"Ubuntu","slug":"Ubuntu","date":"2018-01-02T15:09:00.000Z","updated":"2018-04-13T13:37:52.514Z","comments":true,"path":"2018/01/02/Ubuntu/","link":"","permalink":"http://www.icharles.top/2018/01/02/Ubuntu/","excerpt":"Ubuntu安装教程","text":"Ubuntu安装教程 Ubuntu 16.04安装步骤：一、U盘安装准备步骤 (1) 官网下载 Ubuntu16.04 系统ISO镜像 (2) 准备U盘一个，4G左右就够了，用于制作安装u盘 制作安装U盘，推荐使用软件：universal-usb-installer 将U盘插入电脑 第一步: 下拉列表选择Ubuntu（当然安装其他发行版时也可以选择相应的title）。第二步: 单击右侧的Browse按钮，选择下载好的.iso格式的系统镜像。第三步: 选择插入的U盘，一般默认的就是。根据要求是否进行格式化，其余按照默认的参数，单击create，等待一会儿后就可以了。结束画面如下： 二、Ubuntu系统空间准备 在Windows 10中打开“磁盘管理器”，找一个空闲的磁盘分区，压缩出来一部分空间给Ubuntu使用，压缩出来的硬盘应处于未分配状态。或者通过删除某个不使用的本地磁盘使其处于未分配状态。 绿色框中是留给Ubuntu的空间 三、BIOS设置1.关机，重新打开电脑，进入BIOS，关闭Windows系统的快速启动（Fast Boot）选项，即设置为Disable状态。2.在BIOS中设置U盘为第一启动项，关闭电脑。 四、安装Ubuntu 16.041.从U盘启动，进入刻录到U盘的Ubuntu系统中 2.选择试用Install Ubuntu 在硬盘中Ubuntu检测到有Windows系统存在，所以会默认使用未分配的那部分空间安 装Ubuntu。这也是刚开始说的方便之处，避免了自己分区的不合理当然你也可以选择其他选项自定义安装，分区方案如下： 3.配置完成后，接下来下载更新，自动安装 完成安装后，美化你的Ubuntu吧：美化教程 本文来自于：七双叶","categories":[],"tags":[]},{"title":"俄罗斯方块","slug":"俄罗斯方块","date":"2017-12-29T14:16:00.000Z","updated":"2018-01-27T14:55:10.381Z","comments":true,"path":"2017/12/29/俄罗斯方块/","link":"","permalink":"http://www.icharles.top/2017/12/29/俄罗斯方块/","excerpt":"本文代码下载地址: 俄罗斯方块.c本文程序下载地址: 俄罗斯方块.exe","text":"本文代码下载地址: 俄罗斯方块.c本文程序下载地址: 俄罗斯方块.exe #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;time.h&gt; #include &lt;conio.h&gt; #include &lt;windows.h&gt; #ifdef _MSC_VER // M$的编译器要给予特殊照顾 #if _MSC_VER &lt;= 1200 // VC6及以下版本 #error 你是不是还在用VC6？！ #else // VC6以上版本 #if _MSC_VER &gt;= 1600 // 据说VC10及以上版本有stdint.h了 #include &lt;stdint.h&gt; #else // VC10以下版本，自己定义int8_t和uint16_t typedef signed char int8_t; typedef unsigned short uint16_t; #endif #ifndef __cplusplus // 据说VC都没有stdbool.h，不用C++编译，自己定义bool typedef int bool; #define true 1 #define false 0 #endif #endif #else // 其他的编译器都好说 #include &lt;stdint.h&gt; #ifndef __cplusplus // 不用C++编译，需要stdbool.h里的bool #include &lt;stdbool.h&gt; #endif #endif // ============================================================================= // 7种方块的4旋转状态（4位为一行） static const uint16_t gs_uTetrisTable[7][4] = { { 0x00F0U, 0x2222U, 0x00F0U, 0x2222U }, // I型 { 0x0072U, 0x0262U, 0x0270U, 0x0232U }, // T型 { 0x0223U, 0x0074U, 0x0622U, 0x0170U }, // L型 { 0x0226U, 0x0470U, 0x0322U, 0x0071U }, // J型 { 0x0063U, 0x0264U, 0x0063U, 0x0264U }, // Z型 { 0x006CU, 0x0462U, 0x006CU, 0x0462U }, // S型 { 0x0660U, 0x0660U, 0x0660U, 0x0660U } // O型 }; // ============================================================================= // 初始状态的游戏池 // 每个元素表示游戏池的一行，下标大的是游戏池底部 // 两端各置2个1，底部2全置为1，便于进行碰撞检测 // 这样一来游戏池的宽度为12列 // 如果想要传统的10列，只需多填两个1即可（0xE007），当然显示相关部分也要随之改动 // 当某个元素为0xFFFFU时，说明该行已被填满 // 顶部4行用于给方块，不显示出来 // 再除去底部2行，显示出来的游戏池高度为22行 static const uint16_t gs_uInitialTetrisPool[28] = { 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xC003U, 0xFFFFU, 0xFFFFU }; #define COL_BEGIN 2 #define COL_END 14 #define ROW_BEGIN 4 #define ROW_END 26 // ============================================================================= typedef struct TetrisManager // 这个结构体存储游戏相关数据 { uint16_t pool[28]; // 游戏池 int8_t x; // 当前方块x坐标，此处坐标为方块左上角坐标 int8_t y; // 当前方块y坐标 int8_t type[3]; // 当前、下一个和下下一个方块类型 int8_t orientation[3]; // 当前、下一个和下下一个方块旋转状态 unsigned score; // 得分 unsigned erasedCount[4]; // 消行数 unsigned erasedTotal; // 消行总数 unsigned tetrisCount[7]; // 各方块数 unsigned tetrisTotal; // 方块总数 bool dead; // 挂 } TetrisManager; // ============================================================================= typedef struct TetrisControl // 这个结构体存储控制相关数据 { bool pause; // 暂停 bool clockwise; // 旋转方向：顺时针为true int8_t direction; // 移动方向：0向左移动 1向右移动 // 游戏池内每格的颜色 // 由于此版本是彩色的，仅用游戏池数据无法存储颜色信息 // 当然，如果只实现单色版的，就没必要用这个数组了 int8_t color[28][16]; } TetrisControl; HANDLE g_hConsoleOutput; // 控制台输出句柄 // ============================================================================= // 函数声明 // 如果使用全局变量方式实现，就没必要传参了 void initGame(TetrisManager *manager, TetrisControl *control); // 初始化游戏 void restartGame(TetrisManager *manager, TetrisControl *control); // 重新开始游戏 void giveTetris(TetrisManager *manager); // 给一个方块 bool checkCollision(const TetrisManager *manager); // 碰撞检测 void insertTetris(TetrisManager *manager); // 插入方块 void removeTetris(TetrisManager *manager); // 移除方块 void horzMoveTetris(TetrisManager *manager, TetrisControl *control); // 水平移动方块 void moveDownTetris(TetrisManager *manager, TetrisControl *control); // 向下移动方块 void rotateTetris(TetrisManager *manager, TetrisControl *control); // 旋转方块 void dropDownTetris(TetrisManager *manager, TetrisControl *control); // 方块直接落地 bool checkErasing(TetrisManager *manager, TetrisControl *control); // 消行检测 void keydownControl(TetrisManager *manager, TetrisControl *control, int key); // 键按下 void setPoolColor(const TetrisManager *manager, TetrisControl *control); // 设置颜色 void gotoxyWithFullwidth(short x, short y); // 以全角定位 void printPoolBorder(); // 显示游戏池边界 void printTetrisPool(const TetrisManager *manager, const TetrisControl *control); // 显示游戏池 void printCurrentTetris(const TetrisManager *manager, const TetrisControl *control); // 显示当前方块 void printNextTetris(const TetrisManager *manager); // 显示下一个和下下一个方块 void printScore(const TetrisManager *manager); // 显示得分信息 void runGame(TetrisManager *manager, TetrisControl *control); // 运行游戏 void printPrompting(); // 显示提示信息 bool ifPlayAgain(); // 再来一次 // ============================================================================= // 出处：http://www.oschina.net/code/snippet_255612_16922 // 主函数 int main() { TetrisManager tetrisManager; TetrisControl tetrisControl; initGame(&amp;tetrisManager, &amp;tetrisControl); // 初始化游戏 do { printPrompting(); // 显示提示信息 printPoolBorder(); // 显示游戏池边界 runGame(&amp;tetrisManager, &amp;tetrisControl); // 运行游戏 if (ifPlayAgain()) // 再来一次 { SetConsoleTextAttribute(g_hConsoleOutput, 0x7); system(&quot;cls&quot;); // 清屏 restartGame(&amp;tetrisManager, &amp;tetrisControl); // 重新开始游戏 } else { break; } } while (1); gotoxyWithFullwidth(0, 0); CloseHandle(g_hConsoleOutput); return 0; } // ============================================================================= // 初始化游戏 void initGame(TetrisManager *manager, TetrisControl *control) { CONSOLE_CURSOR_INFO cursorInfo = { 1, FALSE }; // 光标信息 g_hConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE); // 获取控制台输出句柄 SetConsoleCursorInfo(g_hConsoleOutput, &amp;cursorInfo); // 设置光标隐藏 SetConsoleTitleA(&quot;俄罗斯方块&quot;); restartGame(manager, control); } // ============================================================================= // 重新开始游戏 void restartGame(TetrisManager *manager, TetrisControl *control) { memset(manager, 0, sizeof(TetrisManager)); // 全部置0 // 初始化游戏池 memcpy(manager-&gt;pool, gs_uInitialTetrisPool, sizeof(uint16_t[28])); srand((unsigned) time(NULL )); // 设置随机种子 manager-&gt;type[1] = rand() % 7; // 下一个 manager-&gt;orientation[1] = rand() &amp; 3; manager-&gt;type[2] = rand() % 7; // 下下一个 manager-&gt;orientation[2] = rand() &amp; 3; memset(control, 0, sizeof(TetrisControl)); // 全部置0 giveTetris(manager); // 给下一个方块 setPoolColor(manager, control); // 设置颜色 } // ============================================================================= // 给一个方块 void giveTetris(TetrisManager *manager) { uint16_t tetris; manager-&gt;type[0] = manager-&gt;type[1]; // 下一个方块置为当前 manager-&gt;orientation[0] = manager-&gt;orientation[1]; manager-&gt;type[1] = manager-&gt;type[2]; // 下下一个置方块为下一个 manager-&gt;orientation[1] = manager-&gt;orientation[2]; manager-&gt;type[2] = rand() % 7; // 随机生成下下一个方块 manager-&gt;orientation[2] = rand() &amp; 3; tetris = gs_uTetrisTable[manager-&gt;type[0]][manager-&gt;orientation[0]]; // 当前方块 // 设置当前方块y坐标，保证刚给出时只显示方块最下面一行 // 这种实现使得玩家可以以很快的速度将方块落在不显示出来的顶部4行内 if (tetris &amp; 0xF000) { manager-&gt;y = 0; } else { manager-&gt;y = (tetris &amp; 0xFF00) ? 1 : 2; } manager-&gt;x = 6; // 设置当前方块x坐标 if (checkCollision(manager)) // 检测到碰撞 { manager-&gt;dead = true; // 标记游戏结束 } else // 未检测到碰撞 { insertTetris(manager); // 将当前方块加入游戏池 } ++manager-&gt;tetrisTotal; // 方块总数 ++manager-&gt;tetrisCount[manager-&gt;type[0]]; // 相应方块数 printNextTetris(manager); // 显示下一个方块 printScore(manager); // 显示得分信息 } // ============================================================================= // 碰撞检测 bool checkCollision(const TetrisManager *manager) { // 当前方块 uint16_t tetris = gs_uTetrisTable[manager-&gt;type[0]][manager-&gt;orientation[0]]; uint16_t dest = 0; // 获取当前方块在游戏池中的区域： // 游戏池坐标x y处小方格信息，按低到高存放在16位无符号数中 dest |= (((manager-&gt;pool[manager-&gt;y + 0] &gt;&gt; manager-&gt;x) &lt;&lt; 0x0) &amp; 0x000F); dest |= (((manager-&gt;pool[manager-&gt;y + 1] &gt;&gt; manager-&gt;x) &lt;&lt; 0x4) &amp; 0x00F0); dest |= (((manager-&gt;pool[manager-&gt;y + 2] &gt;&gt; manager-&gt;x) &lt;&lt; 0x8) &amp; 0x0F00); dest |= (((manager-&gt;pool[manager-&gt;y + 3] &gt;&gt; manager-&gt;x) &lt;&lt; 0xC) &amp; 0xF000); // 若当前方块与目标区域存在重叠（碰撞），则位与的结果不为0 return ((dest &amp; tetris) != 0); } // ============================================================================= // 插入方块 void insertTetris(TetrisManager *manager) { // 当前方块 uint16_t tetris = gs_uTetrisTable[manager-&gt;type[0]][manager-&gt;orientation[0]]; // 当前方块每4位取出，位或到游戏池相应位置，即完成插入方块 manager-&gt;pool[manager-&gt;y + 0] |= (((tetris &gt;&gt; 0x0) &amp; 0x000F) &lt;&lt; manager-&gt;x); manager-&gt;pool[manager-&gt;y + 1] |= (((tetris &gt;&gt; 0x4) &amp; 0x000F) &lt;&lt; manager-&gt;x); manager-&gt;pool[manager-&gt;y + 2] |= (((tetris &gt;&gt; 0x8) &amp; 0x000F) &lt;&lt; manager-&gt;x); manager-&gt;pool[manager-&gt;y + 3] |= (((tetris &gt;&gt; 0xC) &amp; 0x000F) &lt;&lt; manager-&gt;x); } // ============================================================================= // 移除方块 void removeTetris(TetrisManager *manager) { // 当前方块 uint16_t tetris = gs_uTetrisTable[manager-&gt;type[0]][manager-&gt;orientation[0]]; // 当前方块每4位取出，按位取反后位与到游戏池相应位置，即完成移除方块 manager-&gt;pool[manager-&gt;y + 0] &amp;= ~(((tetris &gt;&gt; 0x0) &amp; 0x000F) &lt;&lt; manager-&gt;x); manager-&gt;pool[manager-&gt;y + 1] &amp;= ~(((tetris &gt;&gt; 0x4) &amp; 0x000F) &lt;&lt; manager-&gt;x); manager-&gt;pool[manager-&gt;y + 2] &amp;= ~(((tetris &gt;&gt; 0x8) &amp; 0x000F) &lt;&lt; manager-&gt;x); manager-&gt;pool[manager-&gt;y + 3] &amp;= ~(((tetris &gt;&gt; 0xC) &amp; 0x000F) &lt;&lt; manager-&gt;x); } // ============================================================================= // 设置颜色 void setPoolColor(const TetrisManager *manager, TetrisControl *control) { // 由于显示游戏池时，先要在游戏池里判断某一方格有方块才显示相应方格的颜色 // 这里只作设置即可，没必要清除 // 当移动方块或给一个方块时调用 int8_t i, x, y; // 当前方块 uint16_t tetris = gs_uTetrisTable[manager-&gt;type[0]][manager-&gt;orientation[0]]; for (i = 0; i &lt; 16; ++i) { y = (i &gt;&gt; 2) + manager-&gt;y; // 待设置的列 if (y &gt; ROW_END) // 超过底部限制 { break; } x = (i &amp; 3) + manager-&gt;x; // 待设置的行 if ((tetris &gt;&gt; i) &amp; 1) // 检测的到小方格属于当前方块区域 { control-&gt;color[y][x] = (manager-&gt;type[0] | 8); // 设置颜色 } } } // ============================================================================= // 旋转方块 void rotateTetris(TetrisManager *manager, TetrisControl *control) { int8_t ori = manager-&gt;orientation[0]; // 记录原旋转状态 removeTetris(manager); // 移走当前方块 // 顺/逆时针旋转 manager-&gt;orientation[0] = (control-&gt;clockwise) ? ((ori + 1) &amp; 3) : ((ori + 3) &amp; 3); if (checkCollision(manager)) // 检测到碰撞 { manager-&gt;orientation[0] = ori; // 恢复为原旋转状态 insertTetris(manager); // 放入当前方块。由于状态没改变，不需要设置颜色 } else { insertTetris(manager); // 放入当前方块 setPoolColor(manager, control); // 设置颜色 printCurrentTetris(manager, control); // 显示当前方块 } } // ============================================================================= // 水平移动方块 void horzMoveTetris(TetrisManager *manager, TetrisControl *control) { int x = manager-&gt;x; // 记录原列位置 removeTetris(manager); // 移走当前方块 control-&gt;direction == 0 ? (--manager-&gt;x) : (++manager-&gt;x); // 左/右移动 if (checkCollision(manager)) // 检测到碰撞 { manager-&gt;x = x; // 恢复为原列位置 insertTetris(manager); // 放入当前方块。由于位置没改变，不需要设置颜色 } else { insertTetris(manager); // 放入当前方块 setPoolColor(manager, control); // 设置颜色 printCurrentTetris(manager, control); // 显示当前方块 } } // ============================================================================= // 向下移动方块 void moveDownTetris(TetrisManager *manager, TetrisControl *control) { int8_t y = manager-&gt;y; // 记录原行位置 removeTetris(manager); // 移走当前方块 ++manager-&gt;y; // 向下移动 if (checkCollision(manager)) // 检测到碰撞 { manager-&gt;y = y; // 恢复为原行位置 insertTetris(manager); // 放入当前方块。由于位置没改变，不需要设置颜色 if (checkErasing(manager, control)) // 检测到消行 { printTetrisPool(manager, control); // 显示游戏池 } } else { insertTetris(manager); // 放入当前方块 setPoolColor(manager, control); // 设置颜色 printCurrentTetris(manager, control); // 显示当前方块 } } // ============================================================================= // 方块直接落地 void dropDownTetris(TetrisManager *manager, TetrisControl *control) { removeTetris(manager); // 移走当前方块 for (; manager-&gt;y &lt; ROW_END; ++manager-&gt;y) // 从上往下 { if (checkCollision(manager)) // 检测到碰撞 { break; } } --manager-&gt;y; // 上移一格当然没有碰撞 insertTetris(manager); // 放入当前方块 setPoolColor(manager, control); // 设置颜色 checkErasing(manager, control); // 检测消行 printTetrisPool(manager, control); // 显示游戏池 } // ============================================================================= // 消行检测 bool checkErasing(TetrisManager *manager, TetrisControl *control) { static const unsigned scores[5] = { 0, 10, 30, 90, 150 }; // 消行得分 int8_t count = 0; int8_t k = 0, y = manager-&gt;y + 3; // 从下往上检测 do { if (y &lt; ROW_END &amp;&amp; manager-&gt;pool[y] == 0xFFFFU) // 有效区域内且一行已填满 { ++count; // 消除一行方块 memmove(manager-&gt;pool + 1, manager-&gt;pool, sizeof(uint16_t) * y); // 颜色数组的元素随之移动 memmove(control-&gt;color[1], control-&gt;color[0], sizeof(int8_t[16]) * y); } else { --y; ++k; } } while (y &gt;= manager-&gt;y &amp;&amp; k &lt; 4); manager-&gt;erasedTotal += count; // 消行总数 manager-&gt;score += scores[count]; // 得分 if (count &gt; 0) { ++manager-&gt;erasedCount[count - 1]; // 消行 } giveTetris(manager); // 给下一个方块 setPoolColor(manager, control); // 设置颜色 return (count &gt; 0); } // ============================================================================= // 键按下 void keydownControl(TetrisManager *manager, TetrisControl *control, int key) { if (key == 13) // 暂停/解除暂停 { control-&gt;pause = !control-&gt;pause; } if (control-&gt;pause) // 暂停状态，不作处理 { return; } switch (key) { case &#39;w&#39;: case &#39;W&#39;: case &#39;8&#39;: case 72: // 上 control-&gt;clockwise = true; // 顺时针旋转 rotateTetris(manager, control); // 旋转方块 break; case &#39;a&#39;: case &#39;A&#39;: case &#39;4&#39;: case 75: // 左 control-&gt;direction = 0; // 向左移动 horzMoveTetris(manager, control); // 水平移动方块 break; case &#39;d&#39;: case &#39;D&#39;: case &#39;6&#39;: case 77: // 右 control-&gt;direction = 1; // 向右移动 horzMoveTetris(manager, control); // 水平移动方块 break; case &#39;s&#39;: case &#39;S&#39;: case &#39;2&#39;: case 80: // 下 moveDownTetris(manager, control); // 向下移动方块 break; case &#39; &#39;: // 直接落地 dropDownTetris(manager, control); break; case &#39;0&#39;: // 反转 control-&gt;clockwise = false; // 逆时针旋转 rotateTetris(manager, control); // 旋转方块 break; default: break; } } // ============================================================================= // 以全角定位 void gotoxyWithFullwidth(short x, short y) { static COORD cd; cd.X = (short) (x &lt;&lt; 1); cd.Y = y; SetConsoleCursorPosition(g_hConsoleOutput, cd); } // ============================================================================= // 显示游戏池边界 void printPoolBorder() { int8_t y; SetConsoleTextAttribute(g_hConsoleOutput, 0xF0); for (y = ROW_BEGIN; y &lt; ROW_END; ++y) // 不显示顶部4行和底部2行 { gotoxyWithFullwidth(10, y - 3); printf(&quot;%2s&quot;, &quot;&quot;); gotoxyWithFullwidth(23, y - 3); printf(&quot;%2s&quot;, &quot;&quot;); } gotoxyWithFullwidth(10, y - 3); // 底部边界 printf(&quot;%28s&quot;, &quot;&quot;); } // 定位到游戏池中的方格 #define gotoxyInPool(x, y) gotoxyWithFullwidth(x + 9, y - 3) // ============================================================================= // 显示游戏池 void printTetrisPool(const TetrisManager *manager, const TetrisControl *control) { int8_t x, y; for (y = ROW_BEGIN; y &lt; ROW_END; ++y) // 不显示顶部4行和底部2行 { gotoxyInPool(2, y); // 定点到游戏池中的方格 for (x = COL_BEGIN; x &lt; COL_END; ++x) // 不显示左右边界 { if ((manager-&gt;pool[y] &gt;&gt; x) &amp; 1) // 游戏池该方格有方块 { // 用相应颜色，显示一个实心方块 SetConsoleTextAttribute(g_hConsoleOutput, control-&gt;color[y][x]); printf(&quot;■&quot;); } else // 没有方块，显示空白 { SetConsoleTextAttribute(g_hConsoleOutput, 0); printf(&quot;%2s&quot;, &quot;&quot;); } } } } // ============================================================================= // 显示当前方块 void printCurrentTetris(const TetrisManager *manager, const TetrisControl *control) { int8_t x, y; // 显示当前方块是在移动后调用的，为擦去移动前的方块，需要扩展显示区域 // 由于不可能向上移动，故不需要向下扩展 y = (manager-&gt;y &gt; ROW_BEGIN) ? (manager-&gt;y - 1) : ROW_BEGIN; // 向上扩展一格 for (; y &lt; ROW_END &amp;&amp; y &lt; manager-&gt;y + 4; ++y) { x = (manager-&gt;x &gt; COL_BEGIN) ? (manager-&gt;x - 1) : COL_BEGIN; // 向左扩展一格 for (; x &lt; COL_END &amp;&amp; x &lt; manager-&gt;x + 5; ++x) // 向右扩展一格 { gotoxyInPool(x, y); // 定点到游戏池中的方格 if ((manager-&gt;pool[y] &gt;&gt; x) &amp; 1) // 游戏池该方格有方块 { // 用相应颜色，显示一个实心方块 SetConsoleTextAttribute(g_hConsoleOutput, control-&gt;color[y][x]); printf(&quot;■&quot;); } else // 没有方块，显示空白 { SetConsoleTextAttribute(g_hConsoleOutput, 0); printf(&quot;%2s&quot;, &quot;&quot;); } } } } // ============================================================================= // 显示下一个和下下一个方块 void printNextTetris(const TetrisManager *manager) { int8_t i; uint16_t tetris; // 边框 SetConsoleTextAttribute(g_hConsoleOutput, 0xF); gotoxyWithFullwidth(26, 1); printf(&quot;┏━━━━┳━━━━┓&quot;); gotoxyWithFullwidth(26, 2); printf(&quot;┃%8s┃%8s┃&quot;, &quot;&quot;, &quot;&quot;); gotoxyWithFullwidth(26, 3); printf(&quot;┃%8s┃%8s┃&quot;, &quot;&quot;, &quot;&quot;); gotoxyWithFullwidth(26, 4); printf(&quot;┃%8s┃%8s┃&quot;, &quot;&quot;, &quot;&quot;); gotoxyWithFullwidth(26, 5); printf(&quot;┃%8s┃%8s┃&quot;, &quot;&quot;, &quot;&quot;); gotoxyWithFullwidth(26, 6); printf(&quot;┗━━━━┻━━━━┛&quot;); // 下一个，用相应颜色显示 tetris = gs_uTetrisTable[manager-&gt;type[1]][manager-&gt;orientation[1]]; SetConsoleTextAttribute(g_hConsoleOutput, manager-&gt;type[1] | 8); for (i = 0; i &lt; 16; ++i) { gotoxyWithFullwidth((i &amp; 3) + 27, (i &gt;&gt; 2) + 2); ((tetris &gt;&gt; i) &amp; 1) ? printf(&quot;■&quot;) : printf(&quot;%2s&quot;, &quot;&quot;); } // 下下一个，不显示彩色 tetris = gs_uTetrisTable[manager-&gt;type[2]][manager-&gt;orientation[2]]; SetConsoleTextAttribute(g_hConsoleOutput, 8); for (i = 0; i &lt; 16; ++i) { gotoxyWithFullwidth((i &amp; 3) + 32, (i &gt;&gt; 2) + 2); ((tetris &gt;&gt; i) &amp; 1) ? printf(&quot;■&quot;) : printf(&quot;%2s&quot;, &quot;&quot;); } } // ============================================================================= // 显示得分信息 void printScore(const TetrisManager *manager) { static const char *tetrisName = &quot;ITLJZSO&quot;; int8_t i; SetConsoleTextAttribute(g_hConsoleOutput, 0xE); gotoxyWithFullwidth(2, 2); printf(&quot;■得分：%u&quot;, manager-&gt;score); gotoxyWithFullwidth(1, 6); printf(&quot;■消行总数：%u&quot;, manager-&gt;erasedTotal); for (i = 0; i &lt; 4; ++i) { gotoxyWithFullwidth(2, 8 + i); printf(&quot;□消%d：%u&quot;, i + 1, manager-&gt;erasedCount[i]); } gotoxyWithFullwidth(1, 15); printf(&quot;■方块总数：%u&quot;, manager-&gt;tetrisTotal); for (i = 0; i &lt; 7; ++i) { gotoxyWithFullwidth(2, 17 + i); printf(&quot;□%c形：%u&quot;, tetrisName[i], manager-&gt;tetrisCount[i]); } } // ============================================================================= // 显示提示信息 void printPrompting() { SetConsoleTextAttribute(g_hConsoleOutput, 0xB); gotoxyWithFullwidth(26, 10); printf(&quot;■控制：&quot;); gotoxyWithFullwidth(27, 12); printf(&quot;□向左移动：← A 4&quot;); gotoxyWithFullwidth(27, 13); printf(&quot;□向右移动：→ D 6&quot;); gotoxyWithFullwidth(27, 14); printf(&quot;□向下移动：↓ S 2&quot;); gotoxyWithFullwidth(27, 15); printf(&quot;□顺时针转：↑ W 8&quot;); gotoxyWithFullwidth(27, 16); printf(&quot;□逆时针转：0&quot;); gotoxyWithFullwidth(27, 17); printf(&quot;□直接落地：空格&quot;); gotoxyWithFullwidth(27, 18); printf(&quot;□暂停游戏：回车&quot;); gotoxyWithFullwidth(25, 23); printf(&quot;■By: wohaaitinciu 12.12.29&quot;); } // ============================================================================= // 运行游戏 void runGame(TetrisManager *manager, TetrisControl *control) { clock_t clockLast, clockNow; clockLast = clock(); // 计时 printTetrisPool(manager, control); // 显示游戏池 while (!manager-&gt;dead) // 没挂 { while (_kbhit()) // 有键按下 { keydownControl(manager, control, _getch()); // 处理按键 } if (!control-&gt;pause) // 未暂停 { clockNow = clock(); // 计时 // 两次记时的间隔超过0.45秒 if (clockNow - clockLast &gt; 0.45F * CLOCKS_PER_SEC ) { clockLast = clockNow; keydownControl(manager, control, 80); // 方块往下移 } } } } // ============================================================================= // 再来一次 bool ifPlayAgain() { int ch; SetConsoleTextAttribute(g_hConsoleOutput, 0xF0); gotoxyWithFullwidth(15, 10); printf(&quot;游戏结束&quot;); gotoxyWithFullwidth(13, 11); printf(&quot;按Y重玩，按N退出&quot;); do { ch = _getch(); if (ch == &#39;Y&#39; || ch == &#39;y&#39;) { return true; } else if (ch == &#39;N&#39; || ch == &#39;n&#39;) { return false; } } while (1); }","categories":[{"name":"Game","slug":"Game","permalink":"http://www.icharles.top/categories/Game/"}],"tags":[{"name":"Game","slug":"Game","permalink":"http://www.icharles.top/tags/Game/"}]},{"title":"贪心","slug":"贪心","date":"2017-12-29T04:18:00.000Z","updated":"2018-01-29T04:19:41.812Z","comments":true,"path":"2017/12/29/贪心/","link":"","permalink":"http://www.icharles.top/2017/12/29/贪心/","excerpt":"题目地址：https://cn.vjudge.net/problem/HDU-1257 分析： 简单的贪心，没必要用dp来做。就是求非连续递减序列的个数。依次往下判断，ans 记录非连续递减序列的个数，a 数组记录各个递减序列的最小值，依次往下判断更新即可。有一点读者可能觉得模糊，如果当前的高度对于前面多个递减序列都适用，那选择哪一个，其实根本不用考虑，随便哪一个，这个仔细想想就有了。","text":"题目地址：https://cn.vjudge.net/problem/HDU-1257 分析： 简单的贪心，没必要用dp来做。就是求非连续递减序列的个数。依次往下判断，ans 记录非连续递减序列的个数，a 数组记录各个递减序列的最小值，依次往下判断更新即可。有一点读者可能觉得模糊，如果当前的高度对于前面多个递减序列都适用，那选择哪一个，其实根本不用考虑，随便哪一个，这个仔细想想就有了。 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;cmath&gt; #include &lt;queue&gt; #include &lt;stack&gt; #include &lt;vector&gt; using namespace std; int a[1005]; int h[1005]; int ans; int n; int main() { while (~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) { for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, h + i); ans = 1; a[1] = h[1]; int j; for (int i = 2; i &lt;= n; i++) { for (j = 1; j &lt;= ans; j++) { if (h[i] &lt; a[j]) { a[j] = h[i]; break; } } if (j &gt; ans) a[++ans] = h[i]; } printf(&quot;%d\\n&quot;, ans); } return 0; }","categories":[],"tags":[]},{"title":"欧几里得算法","slug":"欧几里得算法","date":"2017-12-27T08:29:00.000Z","updated":"2018-01-27T14:55:19.004Z","comments":true,"path":"2017/12/27/欧几里得算法/","link":"","permalink":"http://www.icharles.top/2017/12/27/欧几里得算法/","excerpt":"欧几里得算法计算的是两个自然数a和b的最大公约数，两个数的最大公约数通常写成gcd(a, b)，如果有gcd(a, b)==1，则有a，b互质。","text":"欧几里得算法计算的是两个自然数a和b的最大公约数，两个数的最大公约数通常写成gcd(a, b)，如果有gcd(a, b)==1，则有a，b互质。 欧几里得算法 递归int Gcd(int a, int b) { if(b == 0) return a; return Gcd(b, a % b); } 迭代int Gcd(int a, int b) { while(b != 0) { int r = b; b = a % b; a = r; } return a; } 扩展欧几里得算法 介绍扩展欧几里德算法是用来在已知a, b求解一组p，q使得pa+qb=Gcd(a,b)(根据数论中的相关定理解一定存在，不展开叙述)。扩展欧几里德常用在求解模线性方程及方程组中。 算法 int exGcd(int a, int b, int &amp;x, int &amp;y) { if(b == 0) { x = 1; y = 0; return a; } int r = exGcd(b, a % b, x, y); int t = x; x = y; y = t - a / b * y; return r; } 理解把这个实现和Gcd的递归实现相比，发现多了下面的x,y赋值过程，这就是扩展欧几里德算法的精髓。 可以这样思考: 对于a’ =b , b’ =a%b 而言，我们求得x, y使得a’ x+b’ y=Gcd(a’, b’) 由于b’ = a % b = a - a / b b 那么可以得到 :a’ x + b’ y = Gcd(a’ , b’)===&gt;bx + (a - a/b b)y = Gcd(a’ , b’) = Gcd(a, b) //注意到这里的/是C语言中的出发===&gt;ay + b(x- a/b y) = Gcd(a, b)因此对于a和b而言，他们的相对应的p，q分别是 y和(x-a/by) 推荐文章 ：https://my.oschina.net/u/1780798/blog/646739","categories":[{"name":"算法","slug":"算法","permalink":"http://www.icharles.top/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.icharles.top/tags/算法/"}]},{"title":"Vector--STL","slug":"Vector-STL","date":"2017-12-27T08:27:00.000Z","updated":"2018-01-27T14:55:37.190Z","comments":true,"path":"2017/12/27/Vector-STL/","link":"","permalink":"http://www.icharles.top/2017/12/27/Vector-STL/","excerpt":"vector(向量)vector类称作向量类，它实现了动态数组，用于元素数量变化的对象数组。像数组一样，vector类也用从0开始的下标表示元素的位置；但和数组不同的是，当vector对象创建后，数组的元素个数会随着vector对象元素个数的增大和缩小而自动变化。","text":"vector(向量)vector类称作向量类，它实现了动态数组，用于元素数量变化的对象数组。像数组一样，vector类也用从0开始的下标表示元素的位置；但和数组不同的是，当vector对象创建后，数组的元素个数会随着vector对象元素个数的增大和缩小而自动变化。 用法: #include&lt;vector&gt; using namespace std; vector &lt;int &gt; a int b = 5; a.push_back(b); //该函数下面有详解 cout&lt;&lt;a[0]; //输出结果为5 函数 动作 push_back 在数组的最后添加一个数据 pop_back 去掉数组的最后一个数据 at 得到编号位置的数据 begin 得到数组头的指针 end 得到数组的最后一个单元+1的指针 front 得到数组头的引用 back 得到数组的最后一个单元的引用 max_size 得到vector最大可以是多大 capacity 当前vector分配的大小 size 当前使用数据的大小 resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值 reserve 改变当前vecotr所分配空间的大小 erase 删除指针指向的数据项 clear 清空当前的vector rbegin 将vector反转后的开始指针返回(其实就是原来的end-1) rend 将vector反转构的结束指针返回(其实就是原来的begin-1) empty 判断vector是否为空 swap 与另一个vector交换数据 详细的函数实现功能 ：其中 vector &lt;int&gt; c 函数 动作 c.clear() 移除容器中所有元素。 c.empty() 判断容器是否为空。 c.erase(pos) 删除pos位置之后的一个元素 c.erase(begin,end) 删除[begin,end)区间的元素 c.front() 传回第一个元素 c.insert(pos,elem) 在pos位置之后插入一个elem拷贝 c.pop_back() 删除最后一个元素 c.push_back(elem) 在尾部加入一个元素 c.resize(num) 重新设置该容器的大小 c.size() 回容器中元素的个数 c.begin() 返回指向容器第一个元素的迭代器 c.end() 返回指向容器最后一个元素的迭代器","categories":[{"name":"STL","slug":"STL","permalink":"http://www.icharles.top/categories/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"http://www.icharles.top/tags/STL/"}]},{"title":"位运算技巧","slug":"位运算技巧","date":"2017-12-26T10:03:00.000Z","updated":"2018-01-29T04:15:13.715Z","comments":true,"path":"2017/12/26/位运算技巧/","link":"","permalink":"http://www.icharles.top/2017/12/26/位运算技巧/","excerpt":"一.获得int型最大值代码代码如下:","text":"一.获得int型最大值代码代码如下: int getMaxInt() { return (1&lt;&lt;31) - 1; //2147483647， 由于优先级关系，括号不可省略 } 另一种写法代码代码如下: int getMaxInt() { return -(1&lt;&lt;-1) - 1; //2147483647 } 另一种写法代码代码如下: int getMaxInt() { return ~(1&lt;&lt;31);//2147483647 } C语言中不知道int占几个字节时候代码代码如下: int getMaxInt(){ return ((unsigned int)-1) &gt;&gt; 1;//2147483647 } 二.获得int型最小值复制代码代码如下: int getMinInt() { return 1&lt;&lt;31; //-2147483648 } 另一种写法代码代码如下: int getMinInt(){ return 1 &lt;&lt; -1;//-2147483648 } 三.获得long类型的最大值C语言版代码代码如下: long getMaxLong() { return ((unsigned long)-1) &gt;&gt; 1; //2147483647 } JAVA版代码代码如下: long getMaxLong() { return ((long)1&lt;&lt;127)-1; //9223372036854775807 } 获得long最小值，和其他类型的最大值，最小值同理. 四.乘以2运算代码代码如下: int mulTwo(int n) { //计算n*2 return n&lt;&lt;1; } 五.除以2运算代码代码如下: int divTwo(int n) { //负奇数的运算不可用 return n&gt;&gt;1; //除以2 } 六.乘以2的m次方代码代码如下: int divTwoPower(int n,int m){ //计算n/(2^m) return n&lt;&lt;m; } 七.除以2的m次方代码代码如下: int divTwoPower(int n,int m) { //计算n/(2^m) return n&gt;&gt;m; } 八.判断一个数的奇偶性代码代码如下: boolean isOddNumber(int n) { return (n &amp; 1) == 1; } 九.不用临时变量交换两个数C语言版代码代码如下: void swap(int *a,int *b) { (*a)^=(*b)^=(*a)^=(*b); } 通用版（一些语言中得分开写）代码代码如下: a ^= b; b ^= a; a ^= b; 十.取绝对值代码代码如下: int abs(int n){ return (n ^ (n &gt;&gt; 31)) - (n &gt;&gt; 31); } /* n&gt;&gt;31 取得n的符号，若n为正数，n&gt;&gt;31等于0，若n为负数，n&gt;&gt;31等于-1 若n为正数 n^0=0,数不变，若n为负数有n^-1 需要计算n和-1的补码，然后进行异或运算， 结果n变号并且为n的绝对值减1，再减去-1就是绝对值 */ 十一.取两个数的最大值通用版复制代码代码如下: int max(int a,int b) { return b&amp;((a-b)&gt;&gt;31) | a&amp;(~(a-b)&gt;&gt;31); // 如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1 } C语言版代码代码如下: int max(int x,int y) { return x ^ ((x ^ y) &amp; -(x &lt; y)); /*如果x&lt;y x&lt;y返回1，否则返回0， 与0做与运算结果为0，与-1做与运算结果不变*/ } 十二.取两个数的最小值通用版代码代码如下: int min(int a,int b) { return a&amp;((a-b)&gt;&gt;31) | b&amp;(~(a-b)&gt;&gt;31); // 如果a&gt;=b,(a-b)&gt;&gt;31为0，否则为-1 } C语言版代码代码如下: int min(int x,int y) { return y ^ ((x ^ y) &amp; -(x &lt; y)); // 如果x&lt;y x&lt;y返回1，否则返回0， // 与0做与运算结果为0，与-1做与运算结果不变 } 十三.判断符号是否相同代码如下: boolean isSameSign(int x, int y) { return (x ^ y) &gt; 0; // true 表示 x和y有相同的符号， false表示x，y有相反的符号。 } 十四.计算2的n次方代码代码如下: int getFactorialofTwo(int n) { //n &gt; 0 return 2&lt;&lt;(n-1); //2的n次方 } 十五.判断一个数是不是2的幂代码代码如下: boolean isFactorialofTwo(int n) { return (n &amp; (n - 1)) == 0; // 如果是2的幂，n一定是100... n-1就是1111.... // 所以做与运算结果为0 } 十六.对2的n次方取余代码代码如下: int quyu(int m,int n) { //n为2的次方 return m &amp; (n - 1); // 如果是2的幂，n一定是100... n-1就是1111.... // 所以做与运算结果保留m在n范围的非0的位 } 十七.求两个整数的平均值代码代码如下: int getAverage(int x, int y) { return (x+y) &gt;&gt; 1; ｝ 另一种写法代码代码如下: int getAverage(int x, int y) { return ((x^y) &gt;&gt; 1) + (x&amp;y); // (x^y) &gt;&gt; 1得到x，y其中一个为1的位并除以2， // x&amp;y得到x，y都为1的部分，加一起就是平均数了 } 下面是三个最基本对二进制位的操作十八.从低位到高位,取n的第m位代码代码如下: int getBit(int n, int m) { return (n &gt;&gt; (m-1)) &amp; 1; } 十九.从低位到高位.将n的第m位置1代码代码如下: int setBitToOne(int n, int m) { return n | (1&lt;&lt;(m-1)); // 将1左移m-1位找到第m位，得到000...1...000 // n在和这个数做或运算 } 二十.从低位到高位,将n的第m位置0代码代码如下: int setBitToZero(int n, int m) { return n &amp; ~(1&lt;&lt;(m-1)); // 将1左移m-1位找到第m位，取反后变成111...0...1111 // n再和这个数做与运算 } 另附一些对程序效率上没有实质提高的位运算技巧，一些也是位运算的常识（面试也许会遇到）计算n+1代码代码如下: -~n 计算n-1代码代码如下: ~-n 取相反数代码代码如下: ~n + 1; 另一种写法代码代码如下: (n ^ -1) + 1; if(x == a) x = b; if(x == b) x = a; 代码代码如下: x = a ^ b ^ x; sign函数，参数为n，当n&gt;0时候返回1，n&lt;0时返回-1，n=0时返回0复制代码代码如下: return !!n - (((unsigned)n&gt;&gt;31)&lt;&lt;1);","categories":[],"tags":[]}]}